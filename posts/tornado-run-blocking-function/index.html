<!doctype html><html lang=zh-CN><head><title>Tornado执行阻塞函数 - 世界的过客</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The HTML5 Herald"><meta name=author content="Jay Lau"><meta property="og:title" content="Tornado执行阻塞函数"><meta property="og:description" content="使用Tornado时执行阻塞函数的姿势 很多人使用Tornado的姿势其实都是不对的，很多人都是知乎style地使用Tornado，当然这话是大佬说的。 我脑补了下才反应过来什么叫知乎style，其实就指用Tornado，但是代码里却很多阻塞的。Tornado的文档 guide里异步和非阻塞I/O节第二段就说了： 为了尽量减少并发连接造成的开销，Tornado使用了一种单线程事件循环的方式。 这就意味着所有的应用代码都应该是异步非阻塞的, 因为在同一时间只有一个操作是有效的."><meta property="og:type" content="article"><meta property="og:url" content="https://laujay.com/posts/tornado-run-blocking-function/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-04-18T09:32:17+08:00"><meta property="article:modified_time" content="2018-04-18T09:32:17+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Tornado执行阻塞函数"><meta name=twitter:description content="使用Tornado时执行阻塞函数的姿势 很多人使用Tornado的姿势其实都是不对的，很多人都是知乎style地使用Tornado，当然这话是大佬说的。 我脑补了下才反应过来什么叫知乎style，其实就指用Tornado，但是代码里却很多阻塞的。Tornado的文档 guide里异步和非阻塞I/O节第二段就说了： 为了尽量减少并发连接造成的开销，Tornado使用了一种单线程事件循环的方式。 这就意味着所有的应用代码都应该是异步非阻塞的, 因为在同一时间只有一个操作是有效的."><meta name=generator content="Hugo 0.121.1"><link rel="shortcut icon" href=https://laujay.com/img/favicon.ico><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=https://laujay.com/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://laujay.com/css/styles.css></head><body><div id=container><header><h1><a href=https://laujay.com/>世界的过客</a></h1><ul id=social-media><li><a href=https://github.com/lau-jay title=GitHub><i class="fab fa-github fa-lg"></i></a></li></ul><p><em>每个人获得的东西都恰好是他值得获得的东西</em></p></header><nav><ul><li><a href=https://laujay.com/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://laujay.com/categories><i class="fa-li fa fa-lg"></i><span>Categories</span></a></li><li><a href=https://laujay.com/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li></ul></nav><main><article><h1>Tornado执行阻塞函数</h1><aside><ul><li><time class=post-date datetime=2018-04-18T09:32:17+08:00>Apr 18, 2018</time></li><li>Categories:
<em><a href=https://laujay.com/categories/python>python</a></em></li><li><em><a href=https://laujay.com/tags/tornado>#tornado</a></em></li><li>One minute read</li></ul></aside><div class=featured_image><a href=https://laujay.com/posts/tornado-run-blocking-function/ title=Tornado执行阻塞函数><img src></a></div><h2 id=使用tornado时执行阻塞函数的姿势>使用Tornado时执行阻塞函数的姿势</h2><p>很多人使用Tornado的姿势其实都是不对的，很多人都是知乎style地使用Tornado，当然这话是大佬说的。
我脑补了下才反应过来什么叫知乎style，其实就指用Tornado，但是代码里却很多阻塞的。Tornado的文档
guide里异步和非阻塞I/O节第二段就说了：
<code>为了尽量减少并发连接造成的开销，Tornado使用了一种单线程事件循环的方式。 这就意味着所有的应用代码都应该是异步非阻塞的, 因为在同一时间只有一个操作是有效的.</code>
敲黑板了，这是官方原话，所以这就是正确的使用Tornado的姿势没跑了。</p><h2 id=所以有以下的操作让耗时的阻塞操作变异步的方式>所以有以下的操作让耗时的阻塞操作变异步的方式</h2><p>董伟明大佬的博文<a href=http://www.dongwm.com/archives/shi-yong-tornadorang-ni-de-qing-qiu-yi-bu-fei-zu-sai/>使用tornado让你的请求异步非阻塞</a>
说了我知道的和不知道的方式，欢迎补充。</p><h2 id=官方的做法是>官方的做法是？</h2><p>我想改变公司的知乎style代码，就去啃了下文档，才有了这篇文章的由来，在翻最新的5.x版本文档里，我想起了以前有些卡时间的操作都
用了<code>run_on_exexutor</code>于是就翻到这个函数的文档，然后发现文档里多了句这个<code> In general, using run_in_executor when calling a blocking method is recommended instead of using this decorator when defining a method.</code>
什么时候出现的难道是我以前看英文没认真。于是搜了下这个函数在<a href=http://www.tornadoweb.org/en/stable/guide/coroutines.html#calling-blocking-functions>这里</a>
在文档里看到了这个示例:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@gen.coroutine</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>call_blocking</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> IOLoop<span style=color:#f92672>.</span>current()<span style=color:#f92672>.</span>run_in_executor(blocking_func, args)
</span></span></code></pre></div><p>UPDATE: 这里其实文档有错，在我提的issue之后，文档更为如下，一共需要三个参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>call_blocking</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> IOLoop<span style=color:#f92672>.</span>current()<span style=color:#f92672>.</span>run_in_executor(<span style=color:#66d9ef>None</span>, blocking_func, args)
</span></span></code></pre></div><p>然后跟一个大佬分享了，大佬说那这个blocking_func是任意的都可以么，于是带着这个疑问我再翻了下文档，
点过去看到了这个函数的声明与注释，原来是5.0新加的。<code>Runs a function in a concurrent.futures.Executor</code> 看
到concurrent你们会想到啥，反正我脑子里冒出了ThreadPool和ProcessPool。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run_in_executor</span>(self, executor, func, <span style=color:#f92672>*</span>args):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;Runs a function in a ``concurrent.futures.Executor``. If
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ``executor`` is ``None``, the IO loop&#39;s default executor will be used.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Use `functools.partial` to pass keyword arguments to ``func``.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        .. versionadded:: 5.0
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ThreadPoolExecutor <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>RuntimeError</span>(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;concurrent.futures is required to use IOLoop.run_in_executor&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> executor <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> hasattr(self, <span style=color:#e6db74>&#39;_executor&#39;</span>):
</span></span><span style=display:flex><span>                <span style=color:#f92672>from</span> tornado.process <span style=color:#f92672>import</span> cpu_count
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>_executor <span style=color:#f92672>=</span> ThreadPoolExecutor(max_workers<span style=color:#f92672>=</span>(cpu_count() <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>            executor <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>_executor
</span></span><span style=display:flex><span>        c_future <span style=color:#f92672>=</span> executor<span style=color:#f92672>.</span>submit(func, <span style=color:#f92672>*</span>args)
</span></span><span style=display:flex><span>        <span style=color:#75715e># Concurrent Futures are not usable with await. Wrap this in a</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Tornado Future instead, using self.add_future for thread-safety.</span>
</span></span><span style=display:flex><span>        t_future <span style=color:#f92672>=</span> Future()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>add_future(c_future, <span style=color:#66d9ef>lambda</span> f: chain_future(f, t_future))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> t_future
</span></span></code></pre></div><p>源码如上, 清晰明了，官方也是简单粗暴，耗时的我再开个线程池来处理就好了。
以后如果阻塞的函数都可以用这个run_in_executor了。这样你的代码就能用正确的姿势
跑在Tornado框架里了。</p><p>UPDATE: 我之前提到文档有错，在我提的issue之后，原本以为会从代码层面更改，
结果只改了文档。
然后我提了说这个做法不够优雅，实现run_in_executor的老外说，虽然是有点尴尬，
不过asyncio也是这么处理的，那没辙就这样吧.感兴趣的可以看<a href=https://github.com/tornadoweb/tornado/issues/2493>这里</a></p><p>UPDATE: 我在上文写到了其实现简单粗暴，另开线程。这里要分享的一个坑就是与此相关的。</p><p>最近写的一个东西，使用了很早之前的torndb, 为了不阻塞，使用这个函数去跑，由于会有很高的写数据库。
于是该系统很不稳定，经过排查发现之前这么用没出现问题，一个是因为当时没使用run_int_executor，
而是上篇说的很阻塞的使用。在那种情况下由于tornado的单线程机制，不会有竞争，基本单数据库连接就够了。
而如今用了很多多线程进行写后，数据连接的单例单连接, 而没有用连接池, 就会出现问题了。</p></article><section class=post-nav><ul><li><a href=https://laujay.com/posts/deploy_and_using_https/><i class="fa fa-chevron-circle-left"></i> CentOS升级HTTPS</a></li><li><a href=https://laujay.com/posts/python3-unknow/>不知道的Python3特性 <i class="fa fa-chevron-circle-right"></i></a></li></ul></section><section class=comments-block><button id=show-comments style=display:none><i class="fa fa-comments"></i> Add/View Comments</button></section><section id=disqus_thread></section><script>(function(){if(window.location.hostname=="localhost")return;var t,n=!1,o="lau-jay",s=document.getElementById("show-comments"),i=!0,a=null;if(a)return;s.style.display="",i?e():s.addEventListener("click",e,!1);function e(){if(!n){n=!0;var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+o+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e),document.getElementById("show-comments").style.display="none"}}t=window.location.hash.substr(1),t.length>8&&t.substring(0,8)=="comment-"&&e(),/bot|google|baidu|bing|msn|duckduckgo|slurp|yandex/i.test(navigator.userAgent)&&e()})()</script></main><footer><h6>Copyright © 2016 ~ 2023 - Jay Lau|Theme by <a href=https://github.com/funkydan2/hugo-kiera>kiera</a> |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://laujay.com/index.xml>Subscribe</a></h6></footer></div><script src=https://laujay.com/js/scripts.js></script><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-91611718-2","auto"),ga("send","pageview"))</script></body></html>