<!doctype html><html lang=zh-CN><head><title>Docker Network External - 世界的过客</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The HTML5 Herald"><meta name=author content="Jay Lau"><meta property="og:title" content="Docker Network External"><meta property="og:description" content="在使用docker的过程中，自建开发环境使用docker-compose是非常正常的需求，正常情况下多个容器都是通过一个docker-compose.yml唤起的，并且可以通过services名直接连接而不需要知道依赖的容器的ip地址。然而，如果遇到容器并非定义在同一个yml中的时候，连接容器就会比较麻烦。我见过直接获取对方容器ip来使用的，但是每次都得获取容器ip地址。
参考自"><meta property="og:type" content="article"><meta property="og:url" content="https://laujay.com/posts/docker-network-external/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-08-27T10:41:30+08:00"><meta property="article:modified_time" content="2020-08-27T10:41:30+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker Network External"><meta name=twitter:description content="在使用docker的过程中，自建开发环境使用docker-compose是非常正常的需求，正常情况下多个容器都是通过一个docker-compose.yml唤起的，并且可以通过services名直接连接而不需要知道依赖的容器的ip地址。然而，如果遇到容器并非定义在同一个yml中的时候，连接容器就会比较麻烦。我见过直接获取对方容器ip来使用的，但是每次都得获取容器ip地址。
参考自"><meta name=generator content="Hugo 0.121.1"><link rel="shortcut icon" href=https://laujay.com/img/favicon.ico><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=https://laujay.com/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://laujay.com/css/styles.css></head><body><div id=container><header><h1><a href=https://laujay.com/>世界的过客</a></h1><ul id=social-media><li><a href=https://github.com/lau-jay title=GitHub><i class="fab fa-github fa-lg"></i></a></li></ul><p><em>每个人获得的东西都恰好是他值得获得的东西</em></p></header><nav><ul><li><a href=https://laujay.com/about><i class="fa-li fa fa-lg"></i><span>About</span></a></li><li><a href=https://laujay.com/categories><i class="fa-li fa fa-lg"></i><span>Categories</span></a></li><li><a href=https://laujay.com/tags><i class="fa-li fa fa-lg"></i><span>Tags</span></a></li></ul></nav><main><article><h1>Docker Network External</h1><aside><ul><li><time class=post-date datetime=2020-08-27T10:41:30+08:00>Aug 27, 2020</time></li><li>Categories:
<em><a href=https://laujay.com/categories/tool>tool</a></em></li><li><em><a href=https://laujay.com/tags/docker>#docker</a></em></li><li>One minute read</li></ul></aside><div class=featured_image><a href=https://laujay.com/posts/docker-network-external/ title="Docker Network External"><img src></a></div><blockquote><p>在使用docker的过程中，自建开发环境使用docker-compose是非常正常的需求，正常情况下多个容器都是通过一个docker-compose.yml唤起的，并且可以通过services名直接连接而不需要知道依赖的容器的ip地址。然而，如果遇到容器并非定义在同一个yml中的时候，连接容器就会比较麻烦。我见过直接获取对方容器ip来使用的，但是每次都得获取容器ip地址。</p></blockquote><p><a href=https://stackoverflow.com/questions/39067295/docker-compose-external-container>参考自</a></p><p>在不使用docker-compose的时候可以使用&ndash;link参数如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run --rm --name rds -d redis <span style=color:#75715e># 启动redis</span>
</span></span><span style=display:flex><span>docker run --rm --name app --link rds -d task <span style=color:#75715e># 启动一个应用并连接到rds</span>
</span></span></code></pre></div><p>如果使用docker-compose就简单了:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>:
</span></span><span style=display:flex><span>       <span style=color:#f92672>images</span>: <span style=color:#ae81ff>task</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>depends_on</span>:
</span></span><span style=display:flex><span>         - <span style=color:#ae81ff>reds</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>res</span>:
</span></span><span style=display:flex><span>       <span style=color:#f92672>images</span>: <span style=color:#ae81ff>redis</span>
</span></span></code></pre></div><p>现在要解决不是一个docker-compose.yml或者是与docker run起来的容器链接的问题。</p><p>有几种解决方案，我只推荐使用以下这种方式：</p><p>首先是： app.yml</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>:
</span></span><span style=display:flex><span>       <span style=color:#f92672>images</span>: <span style=color:#ae81ff>task</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>app</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>         - <span style=color:#ae81ff>app_net</span>
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span><span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>app_net</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>external</span>: <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><p>接着是: rds.yml</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>rds</span>:
</span></span><span style=display:flex><span>       <span style=color:#f92672>images</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>rds</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>         - <span style=color:#ae81ff>app_net</span>
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span><span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>app_net</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>external</span>: <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><p>使用的时候:</p><p>deploy.sh :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>docker network create app_net
</span></span><span style=display:flex><span>docker-compose -f ./deploy/rds.yml up -d
</span></span><span style=display:flex><span>sleep <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>docker-compose -f ./deploy/app.yml up -d
</span></span></code></pre></div><p>接着可以测试下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker exec -it app ping rds
</span></span></code></pre></div><p>正常情况下会得到ping的结果，是通的。</p><p>如果这时候有一个已经存在的容器db，要使用的话可以:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker network connect app_net db
</span></span></code></pre></div><p>这样三个容器都可以互通了。</p></article><section class=post-nav><ul><li><a href=https://laujay.com/posts/mq-rabbitmq/><i class="fa fa-chevron-circle-left"></i> MQ-RabbitMQ</a></li><li><a href=https://laujay.com/posts/2020/>2020我做了什么 <i class="fa fa-chevron-circle-right"></i></a></li></ul></section><section class=comments-block><button id=show-comments style=display:none><i class="fa fa-comments"></i> Add/View Comments</button></section><section id=disqus_thread></section><script>(function(){if(window.location.hostname=="localhost")return;var t,n=!1,o="lau-jay",s=document.getElementById("show-comments"),i=!0,a=null;if(a)return;s.style.display="",i?e():s.addEventListener("click",e,!1);function e(){if(!n){n=!0;var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+o+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e),document.getElementById("show-comments").style.display="none"}}t=window.location.hash.substr(1),t.length>8&&t.substring(0,8)=="comment-"&&e(),/bot|google|baidu|bing|msn|duckduckgo|slurp|yandex/i.test(navigator.userAgent)&&e()})()</script></main><footer><h6>Copyright © 2016 ~ 2023 - Jay Lau|Theme by <a href=https://github.com/funkydan2/hugo-kiera>kiera</a> |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://laujay.com/index.xml>Subscribe</a></h6></footer></div><script src=https://laujay.com/js/scripts.js></script><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-91611718-2","auto"),ga("send","pageview"))</script></body></html>