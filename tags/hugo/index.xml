<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hugo on 世界的过客</title><link>https://laujay.com/tags/hugo/</link><description>Recent content in Hugo on 世界的过客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>Copyright &amp;copy; 2016 ~ 2023 - Jay Lau|Theme by [kiera](https://github.com/funkydan2/hugo-kiera)</copyright><lastBuildDate>Sun, 06 Dec 2020 18:00:59 +0800</lastBuildDate><atom:link href="https://laujay.com/tags/hugo/index.xml" rel="self" type="application/rss+xml"/><item><title>在迷茫中前进，路不是想出来的是走出来的</title><link>https://laujay.com/posts/2023/</link><pubDate>Sat, 30 Dec 2023 18:15:37 +0800</pubDate><guid>https://laujay.com/posts/2023/</guid><description>&lt;h2 id="技术">技术&lt;/h2>&lt;h3 id="开源">开源&lt;/h3>&lt;p>今年开源基本啥也没参与, github上的commit比我的脸还干净，可能这就是一个用不够时尚但是够成熟的技术栈的代价。工作中不会遇到需要解决的技术问题，业余对解决开源问题也没兴趣，有时间就想晒太阳喝咖啡，也不错。生活不只有代码嘛。&lt;/p>&lt;h3 id="web3技术">Web3技术&lt;/h3>&lt;ul>&lt;li>复习和再学习了一次solidity&lt;/li>&lt;li>实践性的写了部分合约demo，对整体的开发流程有了更进一步的了解，虽然最后合约代码不由我来实现，但是算入门了&lt;/li>&lt;/ul>&lt;p>一大体会是整个智能合约生态体系（不管是EVM兼容还是不兼容）很像当初计算机蛮荒时代，各种各样的轮子都需要再造一遍，但是不同的是这个事儿已经做过一遍了，无非是披上密码学的皮再来一次，web2和web3的技术鸿沟其实没那么大, 无非是关注点不同。&lt;/p>&lt;h2 id="生活">生活&lt;/h2>&lt;h3 id="奔波在路上">奔波在路上&lt;/h3>&lt;p>今年一小部分时间在老家，陪父母吃饭，帮父亲做做活，陪母亲遛狗散步，他们是日渐苍老了，这是必然的事儿，不光他们，我自己也是白发日见增多了，肉体上步入而立了，父母亲朋的话题渐渐转向我该成家了，大概在他们的心中很多事儿应该顺理成章吧，可惜我却不愿意顺理成章，心态上还没准备，当然可能永远准备不好。那就顺其自然吧，能终成眷属最好，孑然一身也不是坏事儿。大部分时间在云南保持着忙碌的工作，忙里偷闲给自己来些放松，小部分时间奔波在路上，所以在很多地方带来了自己的办公，酒店里，咖啡馆里，峨眉山脚下，动车站，动车上，机场。也算是有点远程的味道了。12月27，28号两天参加了大学舍友的婚礼 ，我算是大学舍友代表了，只有我去了，总算没让舍友的大学生涯不存在。看着种种传统仪式的进行,突然在思考，仪式存在的意义到底是什么，慰藉先人，给生者一丝宽慰，还是一种宣告，宣告家庭迎来了新成员，看着舍友父母劳累但是充满满足的脸庞，看着舍友和其夫人站在众人面前合影，想来大约是都有吧！&lt;/p>&lt;h2 id="最后">最后&lt;/h2>&lt;p>希望自己身体健康，父母身体健康，毕竟我刚回福建就感冒了，惯例展望下2024，英语水平上升，体脂率下降。&lt;/p></description></item><item><title>22端口踩坑记</title><link>https://laujay.com/posts/shellclash-22-port-key-exchange-error/</link><pubDate>Sun, 10 Sep 2023 20:02:10 +0800</pubDate><guid>https://laujay.com/posts/shellclash-22-port-key-exchange-error/</guid><description>&lt;h1 id="问题">问题&lt;/h1>&lt;p>git pull 我的 Github 私人仓库，通过ssh，命令行报错&lt;/p>&lt;pre tabindex="0">&lt;code>kex_exchange_identification: Connection closed by remote hostConnection closed by 198.18.0.18 port 22fatal: Could not read from remote repository.&lt;/code>&lt;/pre>&lt;h1 id="问题原因">问题原因&lt;/h1>&lt;p>最开始看这个ip就觉得怪怪, 当然不记得了后来查了这个网段是用于子网的保留网段。第一个怀疑的是装了shellclash的路由器，直接换了一个路由器使用电脑的clash用原来的机场配置就能直接拉代码下来。证明了两点:&lt;/p>&lt;ul>&lt;li>第一 我的代理没坏，但是节点就不好说了&lt;/li>&lt;li>第二 我路由器可能至少是shellclash配置有问题&lt;/li>&lt;/ul>&lt;p>所以一开始直接改shellclash规则Direct github.com 但是吧, 他慢。。连网页访问都慢了。就去搜了下&lt;/p>&lt;h1 id="解决方案">解决方案&lt;/h1>&lt;p>&lt;a href="https://github.com/vernesong/OpenClash/issues/1960">这个回答解决了问题&lt;/a>这个回答有两个答案可以适用，第一种是Direct 22 这个网页访问可以，但是命令行还是慢我就选了方法二直接在ssh config里把端口从22改成了443&lt;/p>&lt;pre tabindex="0">&lt;code>Host github.comPort 443&lt;/code>&lt;/pre></description></item><item><title>2022</title><link>https://laujay.com/posts/2022/</link><pubDate>Fri, 30 Dec 2022 09:08:37 +0800</pubDate><guid>https://laujay.com/posts/2022/</guid><description>&lt;h2 id="技术">技术&lt;/h2>&lt;h3 id="开源">开源&lt;/h3>&lt;p>今年开源基本啥也没参与唯一的一个是体验tokei的时候觉得默认行为有点不太友好。经过issue的讨论，采纳了一个人的建议，提了一个PR选择文档增加了相关行为描述用作提示。忘记放了多久了突然有天被作者合并了。hah虽迟但合。&lt;/p>&lt;h3 id="web3技术">Web3技术&lt;/h3>&lt;ul>&lt;li>读了精通以太坊作为进一步了解以太坊细节的读物，这书质量蛮高的。&lt;/li>&lt;li>复习和再学习了一次solidity&lt;/li>&lt;li>分析了DEFI借贷协议compound的代码，对主要架构合约关系了有了认知，其代码实现的很好&lt;/li>&lt;li>阅读了openzeppelin的部分库代码，读了部分博客&lt;/li>&lt;/ul>&lt;p>体会是，Web3技术确实是多种技术的综合运用，涉及的面极广，合约的编写是真的受限，很多约定俗成的暗知识需要积累后才能知道。整体而言处于极早期，并没有互联网这么多年对很多方面都有成熟的解决方案，生态和工具最好的语言是js/ts，其次才是其他语言。不过已经开始百花齐放了，光合约的编程语言已经有多种了，Move，Rust，Solidity, Vyper等。&lt;/p>&lt;h2 id="生活">生活&lt;/h2>&lt;h3 id="换城市生活">换城市生活&lt;/h3>&lt;p>今年一小部分时间在老家，一小部分在深圳，但是深圳的生活由于需要出门就需要核酸，过于麻烦，再加上一些契机，6月底处理好事宜，给我21领养的Corgi麦片找了好人家领养之后，我打包家当，收拾行李，完全搬到云南大理旅居了。下半年与美好的阳光，空气，美景为伴。&lt;/p>&lt;h3 id="阳了">阳了&lt;/h3>&lt;p>终究还是应阳尽阳，在12月26，22年倒数的时间里阳了，整体体验那叫一个痛苦，全靠两颗布洛芬缓释胶囊熬过了艰难的第一天, 第一天浑身酸痛，坐立不安，之后倒还好，很快就恢复了精神，不过写本文的时候还在咳嗽。&lt;/p>&lt;h2 id="最后">最后&lt;/h2>&lt;p>铭记该铭记的，不要被表面的歌舞升平蒙蔽。惯例展望下2023，英语水平上升，体脂率下降。&lt;/p></description></item><item><title>Contract Proxy patterns</title><link>https://laujay.com/posts/proxy-patterns/</link><pubDate>Sun, 11 Dec 2022 10:00:17 +0800</pubDate><guid>https://laujay.com/posts/proxy-patterns/</guid><description>&lt;blockquote>&lt;p>&lt;a href="https://blog.openzeppelin.com/proxy-patterns/">Proxy Patterns&lt;/a>注意原文成文时的solidity 版本为v0.4.21思想可以参考实现可以略过&lt;/p>&lt;/blockquote>&lt;p>以太坊最大的优势之一是，每一笔移动资金的交易，每一份部署的合约，以及对合约进行的每一笔交易，在我们称为区块链的公共账本上都是不可改变的。没有办法隐藏或修改任何曾经的交易。巨大的好处是，以太坊网络上的任何节点都可以验证每笔交易的有效性和状态，使以太坊成为非常强大鲁棒的去中心化系统。&lt;/p>&lt;p>但最大的缺点是，在你的智能合约被部署后，你不能改变它的源代码。从事中心化应用程序（如Facebook，或Airbnb）的开发人员习惯于频繁更新，以修复错误或引入新功能。这在以太坊的传统模式下是不可能做到的。&lt;/p>&lt;p>还记得臭名昭著的Parity Wallet Multisig黑客攻击事件，15万ETH被盗？在这次攻击中，Parity multisig 钱包合约中的一个漏洞被利用了，知名的钱包被抽走了资金。唯一可以做的应对是尝试比黑客更快，利用同样的漏洞入侵剩余的钱包，在攻击后将ETH重新分配给他们的合法主人。&lt;/p>&lt;p>如果有办法在智能合约部署后更新源代码就好了。。。&lt;/p>&lt;h2 id="proxy-patterns介绍">Proxy patterns介绍&lt;/h2>&lt;p>虽然不可能升级你已经部署的智能合约的代码，但可以设置一个代理合约架构，让你使用新部署的合约，就像你的主逻辑被升级了一样。&lt;/p>&lt;p>代理架构模式是这样的，所有的消息调用都要经过一个代理合约，它将把它们重定向到最新部署的合约逻辑。为了升级，你的逻辑合约的一个新版本被部署，代理内保存的逻辑合约地址被更新以引用新的合约。逻辑合约&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/proxy-intro.svg" alt="proxy-intro">&lt;/p>&lt;p>Zeppelin一直在研究几种代理模式，作为他们实现zeppelin_os工作的一部分。探讨的三种方案是:&lt;/p>&lt;ol>&lt;li>继承存储(inherited Storage)&lt;/li>&lt;li>永恒的存储(Eternal Storage)&lt;/li>&lt;li>非结构化存储(Unstructured Storage)&lt;/li>&lt;/ol>&lt;p>这三种模式都依赖于低级别的委托调用。尽管Solidity提供了一个委托调用函数，但它只返回调用是否成功的true/false，不允许你管理返回的数据。&lt;/p>&lt;p>在我们深入研究之前，有两个重要的概念需要了解:&lt;/p>&lt;ul>&lt;li>当一个合约对函数调用的函数不支持时，将调用fallback 函数。你可以写一个自定义的fallback 函数来处理这种情况。代理合约使用自定义fallback 函数来重定向对其他合约实现的调用。&lt;/li>&lt;li>每当一个合约A 调用委托给另一个合约B时，它在合约A的上下文中执行合约B的代码，意味着msg.value和msg.sender的值将被保留，每一次存储修改都会影响合约A的存储。&lt;/li>&lt;/ul>&lt;p>&lt;a href="https://github.com/zeppelinos/labs/blob/master/upgradeability_using_eternal_storage/contracts/Proxy.sol">Zeppelin&amp;rsquo;s Proxy contract&lt;/a> 的代理合约分享了所有代理模式，它为这个特殊的原因实现了自己的委托调用函数，该函数返回调用逻辑合约的结果值。如果你打分享了使用Zeppelin的代理合约代码，你应该充分了解你要使用的代码。让我们来探讨一下它到底是如何工作的，并了解, 它用来实现这一目的的汇编操作码。(请随时参考Solidity的&lt;a href="https://docs.soliditylang.org/en/v0.4.21/assembly.html">Assembly文档&lt;/a>以获得更多信息)&lt;/p>&lt;pre tabindex="0">&lt;code>[assembly { let ptr := mload(0x40) calldatacopy(ptr, 0, calldatasize) let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0) let size := returndatasize returndatacopy(ptr, 0, size) switch result case 0 { revert(ptr, size) } default { return(ptr, size) } }&lt;/code>&lt;/pre>&lt;p>为了委托调用另一个solidity合约函数，我们必须把代理收到的msg.data传递给它。由于msg.data是字节类型的，是一个动态的数据结构，它有一个变化的大小，存储在msg.data的第一个字（32 bytes）。如果我们想只提取实际的数据，我们需要跨过第一个字的大小，从msg.data的&lt;code>0x20&lt;/code> （32 bytes）开始。然而，我们将利用两个操作码来代替这个操作。我们将使用&lt;code>calldatasize&lt;/code> 来获取msg.data的大小，并使用&lt;code>calldatacopy&lt;/code> 将其复制到我们的&lt;code>ptr&lt;/code> 变量。&lt;/p>&lt;p>注意我们是如何初始化我们的ptr变量的。在Solidity中，位于&lt;code>0x40&lt;/code> 位置的内存槽是特殊的，因为它包含了下一个可用的自由内存指针的值。每次你直接保存一个变量到内存，你应该通过检查 &lt;code>0x40&lt;/code> 的值来咨询你应该把它保存到哪里。现在我们知道了允许我们保存变量的位置，我们可以使用&lt;code>calldatacopy&lt;/code> 将大小为&lt;code>calldatasize&lt;/code> 的&lt;code>calldata&lt;/code> 从调用数据的&lt;code>0&lt;/code> 开始复制到&lt;code>ptr&lt;/code> 的位置。&lt;/p>&lt;pre tabindex="0">&lt;code>let ptr := mload(0x40)calldatacopy(ptr, 0, calldatasize)&lt;/code>&lt;/pre>&lt;p>让我们看看汇编块中使用&lt;code>delegatecall&lt;/code> 操作码的下面一行。&lt;/p>&lt;pre tabindex="0">&lt;code>let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)&lt;/code>&lt;/pre>&lt;p>** Parameters **&lt;/p>&lt;ul>&lt;li>gas 我们传入执行函数所需的gas&lt;/li>&lt;li>&lt;code>_impl&lt;/code> 我们要调用的逻辑合约的地址&lt;/li>&lt;li>&lt;code>ptr&lt;/code> 数据开始位置的内存指针&lt;/li>&lt;li>&lt;code>calldatasize&lt;/code> 我们要传递的数据的大小&lt;/li>&lt;li>0，代表调用逻辑合约后的返回值的数据。这是未使用的，因为我们还不知道数据的大小，因此不能把它分配给一个变量。我们仍然可以在以后使用 &lt;code>returndata&lt;/code> 操作码访问这一信息&lt;/li>&lt;li>0, 为返回值大小。这是未使用的，因为我们没有机会创建一个临时变量来存储数据出来，因为我们在调用其他合约之前不知道它的大小。我们可以用另一种方式获得这个值，即在后面调用&lt;code>returndatasize&lt;/code> 操作码&lt;/li>&lt;/ul>&lt;p>下一行使用 &lt;code>returndatasize&lt;/code> 操作码抓取返回数据的大小&lt;/p>&lt;pre tabindex="0">&lt;code>let size := returndatasize&lt;/code>&lt;/pre>&lt;p>我们使用返回数据的大小来复制返回数据的内容到我们的 &lt;code>ptr&lt;/code> 变量上，并使用一个辅助操作码函数 &lt;code>returndatacopy&lt;/code>&lt;/p>&lt;pre tabindex="0">&lt;code>returndatacopy(ptr, 0, size)&lt;/code>&lt;/pre>&lt;p>最后，switch语句要么返回返回的数据，要么在出错时抛出一个异常。&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/proxy-data-flow.svg" alt="proxy-data-flow">&lt;/p>&lt;p>很好，我们现在有办法从逻辑合同中检索到适当的结果值。&lt;/p>&lt;p>现在我们了解了代理合约的工作原理，让我们看看Zeppelin提出的三种模式。使用继承存储的可升级性、非结构化存储和永恒的存储。&lt;/p>&lt;p>这三种方法有不同的方式来解决相同的技术难题：如何确保逻辑合约不会覆盖用于可升级性代理的状态变量。&lt;/p>&lt;p>任何代理架构模式的主要问题是如何处理存储分配。请记住，由于我们是用一个合约来处理存储，另一个合约来处理逻辑，任何一个合约都有可能覆盖一个已经使用过的存储槽。这意味着，如果代理合约有一个状态变量来跟踪某个存储槽的最新逻辑合约地址，而逻辑合约不知道，那么逻辑合约就可能在同一槽中存储一些其他数据，从而覆盖代理的关键信息。Zeppelin的三种方法提出了不同的方法来架构你的系统，使你的合约可以通过代理模式来升级。&lt;/p>&lt;h2 id="使用继承存储inherited-storage升级">使用继承存储（Inherited Storage）升级&lt;/h2>&lt;p>&lt;a href="https://github.com/OpenZeppelin/openzeppelin-labs/tree/master/upgradeability_using_inherited_storage">继承存储&lt;/a>的方法依赖于使逻辑合约包含代理所需的存储结构。代理和逻辑合约都继承了相同的存储结构，以确保两者都坚持存储必要的代理状态变量。&lt;/p>&lt;p>在探索这种方法的时候，我们尝试了由一个注册表合约来跟踪你的逻辑合约的不同版本的想法。为了升级到一个新的逻辑合约，你需要在注册表中把它注册为一个新的版本，并要求代理升级到它。请注意，拥有一个注册表并不影响存储机制；事实上，它可以用本帖中显示的任何一种存储模式来实现。&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/inherited-storage.png" alt="inherited Storage">&lt;/p>&lt;h3 id="如何初始化">如何初始化&lt;/h3>&lt;ol>&lt;li>部署Registry合约&lt;/li>&lt;li>部署你的合约的初始版本（v1）。确保它继承了可升级合约&lt;/li>&lt;li>将你的初始版本的地址注册到&lt;code>Registry&lt;/code>&lt;/li>&lt;li>要求 &lt;code>Registry&lt;/code> 合约创建一个 &lt;code>UpgradeabilityProxy&lt;/code> 实例&lt;/li>&lt;li>调用你的 &lt;code>UpgradeabilityProxy&lt;/code> 以升级到合约的初始版本&lt;/li>&lt;/ol>&lt;h3 id="如何升级">如何升级&lt;/h3>&lt;ol>&lt;li>部署一个新版本的合约（v2），它继承了你的初始版本，以确保它保持代理的存储结构和初始版本的合约中的存储结构。&lt;/li>&lt;li>将你的新版合约注册到 &lt;code>Registry&lt;/code>&lt;/li>&lt;li>调用你的 &lt;code>UpgradeabilityProxy&lt;/code> 以升级到合约的新注册版本&lt;/li>&lt;/ol>&lt;h3 id="总结">总结&lt;/h3>&lt;p>我们可以在未来部署的逻辑合约中引入升级的函数以及新的函数和新的状态变量，方法是仍然调用相同的 &lt;code>UpgradeabilityProxy&lt;/code> 合约&lt;/p>&lt;h2 id="使用永恒存储eternal-storage升级">使用永恒存储（Eternal Storage）升级&lt;/h2>&lt;p>在&lt;a href="https://github.com/OpenZeppelin/openzeppelin-labs/tree/master/upgradeability_using_eternal_storage">永恒存储&lt;/a> 模式中，存储模式被定义在一个单独的合约中，代理和逻辑合约都继承于此。存储合约持有逻辑合约需要的所有状态变量，由于代理也知道这些变量，所以它可以定义自己的可升级性所需的状态变量，而不用担心它们被覆盖。请注意，所有未来版本的逻辑合约不应该定义任何其他的状态变量。所有版本的逻辑合约必须始终使用一开始定义的永恒的存储结构。&lt;/p>&lt;p>Zeppelin lab的代码库中提供的这个实现也引入了代理所有权的概念。代理所有者是唯一能够升级代理以指向新的逻辑合约的地址，也是唯一能够转移所有权的地址。&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/eternal-proxy.png" alt="eternal proxy">&lt;/p>&lt;h3 id="如何初始化-1">如何初始化&lt;/h3>&lt;ol>&lt;li>部署 &lt;code>EternalStorageProxy&lt;/code>&lt;/li>&lt;li>部署合约的初始版本 (v1)&lt;/li>&lt;li>调用你的 &lt;code>EternalStorageProxy&lt;/code> 实例来升级到你的初始版本的地址&lt;/li>&lt;li>如果你的逻辑合约依赖它的构造函数来设置一些初始状态，那就必须在它链接到代理后重做，因为代理的存储不知道这些值。&lt;code>EternalStorageProxy有&lt;/code> 一个函数 &lt;code>upgradeToAndCall&lt;/code>，专门用来调用你的逻辑合约上的一些函数，在代理升级到它之后重新进行设置。&lt;/li>&lt;/ol>&lt;h3 id="如何升级-1">如何升级&lt;/h3>&lt;ol>&lt;li>部署一个新版本的合约(v2)， 确保它拥有永恒的存储结构。&lt;/li>&lt;li>调用你的&lt;code>EternalStorageProxy&lt;/code> 实例来升级到新版本。&lt;/li>&lt;/ol>&lt;h3 id="总结-1">总结&lt;/h3>&lt;p>直观的方法，对代币逻辑合约没有明显的开销。未来的逻辑接触可以升级现有的方法和引入新的方法，但不应该引入新的状态变量。&lt;/p>&lt;h2 id="使用非结构化存储unstructured-storage升级">使用非结构化存储（Unstructured Storage）升级&lt;/h2>&lt;p>&lt;a href="https://github.com/OpenZeppelin/openzeppelin-labs/tree/master/upgradeability_using_unstructured_storage">非结构化存储模式&lt;/a> 与继承性存储相似，但不要求逻辑契约继承任何与可升级性相关的状态变量。这种模式使用代理合约中定义的非结构化存储槽来保存可升级性所需的数据。&lt;/p>&lt;p>在代理合约中，我们定义了一个常量变量，当哈希运算时，应该给出一个足够随机的存储位置来存储代理应该调用的逻辑合约的地址。&lt;/p>&lt;pre tabindex="0">&lt;code>bytes32 private constant implementationPosition = keccak256(&amp;#34;org.zeppelinos.proxy.implementation&amp;#34;);&lt;/code>&lt;/pre>&lt;p>由于&lt;a href="http://solidity.readthedocs.io/en/v0.4.21/miscellaneous.html#modifiers">常量状态变量&lt;/a> 不占用存储槽，所以不存在实现位置被逻辑合约意外覆盖的问题。由于Solidity它的&lt;a href="http://solidity.readthedocs.io/en/v0.4.21/miscellaneous.html#layout-of-state-variables-in-storage">状态变量&lt;/a>存储中的布局方式，这个存储合约槽被逻辑合约中定义的其他东西使用的碰撞机会极少。&lt;/p>&lt;p>通过使用这种模式，没有一个逻辑合约版本必须知道代理的存储结构，然而所有未来的逻辑合约必须继承其祖先版本所声明的存储变量。就像在继承存储模式中，未来升级的代币逻辑合约可以升级现有的功能，也可以引入新的功能和新的存储变量。&lt;/p>&lt;p>Zeppelin lab的代码库中提供的这个实现也引入了代理所有权的概念。代理所有者是唯一能够升级代理以指向新的逻辑合约的地址，也是唯一能够转移所有权的地址。&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/unstructured-proxy.png" alt="unstructured proxy">&lt;/p>&lt;h3 id="如何初始化-2">如何初始化&lt;/h3>&lt;ol>&lt;li>部署 &lt;code>OwnedUpgradeabilityProxy&lt;/code>实例&lt;/li>&lt;li>部署合约的初始版本 (v1)&lt;/li>&lt;li>调用你的 &lt;code>OwnedUpgradeabilityProxy&lt;/code> 实例来升级到你的初始版本的地址&lt;/li>&lt;li>如果你的逻辑合约依赖它的构造函数来设置一些初始状态，那就必须在它链接到代理后重做，因为代理的存储不知道这些值。&lt;code>OwnedUpgradeabilityProxy&lt;/code> 有一个函数 &lt;code>upgradeToAndCall&lt;/code>，专门用来调用你的逻辑合约上的一些函数，在代理升级到它之后重新进行设置。&lt;/li>&lt;/ol>&lt;h3 id="如何升级-2">如何升级&lt;/h3>&lt;ol>&lt;li>部署一个新版本的合约(v2)， 确保它继承了以前版本中使用的状态变量结构。&lt;/li>&lt;li>调用你的&lt;code>OwnedUpgradeabilityProxy&lt;/code> 实例来升级到新版本。&lt;/li>&lt;/ol>&lt;h3 id="总结-2">总结&lt;/h3>&lt;p>这种方法很好，因为它不需要Token逻辑合约意识到它是代理合约系统的一部分。&lt;/p></description></item><item><title>Python的幕后#2: CPython 编译器是如何工作的</title><link>https://laujay.com/posts/how-the-cpython-compiler-works/</link><pubDate>Sun, 26 Jun 2022 20:32:50 +0800</pubDate><guid>https://laujay.com/posts/how-the-cpython-compiler-works/</guid><description>&lt;blockquote>&lt;p>&lt;a href="https://tenthousandmeters.com/blog/python-behind-the-scenes-2-how-the-cpython-compiler-works/">原文&lt;/a>&lt;/p>&lt;p>本文已获原文作者&lt;a href="https://tenthousandmeters.com/about/">Victor Skvortsov&lt;/a>授权&lt;/p>&lt;/blockquote>&lt;p>在本系列的 &lt;a href="https://laujay.com/posts/how-the-cpython-vm-works/">第一篇&lt;/a> 中我们介绍了CPython VM。我们已经了解到它可以通过执行一系列称为字节码的指令来工作。 我们还看到，Python字节码不足以完整描述一段代码的功能。 这就是为什么存在代码对象的原因。执行代码块比如模块或者函数意味着执行相应的代码对象。代码对象包含了代码块的字节码， 该代码块中使用的常量和变量以及代码块的各种属性。&lt;/p>&lt;p>通常，Python程序员不编写字节码，也不创建代码对象，而是编写普通的Python代码。 因此，CPython必须能够从源代码创建代码对象。 这项工作由CPython编译器完成。 在这一部分中，我们将探讨其工作原理。&lt;/p>&lt;p>&lt;strong>Note&lt;/strong>: 在本文中，我指的是CPython 3.9。 随着CPython的发展，某些实现细节肯定会发生变化。 我将尝试跟踪重要的更改并添加更新说明。&lt;/p>&lt;h3 id="什么是cpython-编译器">什么是CPython 编译器？&lt;/h3>&lt;p>我们了解了CPython编译器的职责，但是在研究其实现方式之前，让我们弄清楚为什么首先将其称为编译器。&lt;/p>&lt;p>一般而言，编译器是将一种语言的程序等价翻译成另一种语言的程序的程序。 编译器的类型很多，但是在大多数情况下，编译器是指静态编译器，它可以将高级语言的程序转换为机器代码。 CPython编译器与这种类型的编译器有共同点吗？ 为了回答这个问题，让我们看一下传统静态编译器的三阶段设计。&lt;/p>&lt;p>&lt;a href="https://laujay.com/img/diagram1.png">图1&lt;/a>&lt;/p>&lt;p>编译器的前端将源代码转换为某种中间表示（IR）。 然后，优化器获取一个IR，对其进行优化，然后将优化的IR传递给生成机器代码的后端。 如果我们选择不是特定于任何源语言和任何目标机器的IR，那么我们将获得三阶段设计的主要好处：对于支持新语言的编译器，仅需要一个附加的前端，并且支持一个新的目标平台，只需要一个新的后端。&lt;/p>&lt;p>LLVM工具链是该模型成功的一个很好的例子。 有一些C，Rust，Swift和许多其他编程语言的前端，它们依赖LLVM提供编译器的更复杂部分。 LLVM的创建者Chris Lattner很好地概述了&lt;a href="http://aosabook.org/en/llvm.html">其体系结构&lt;/a>。&lt;/p>&lt;p>但是，CPython不需要支持多种语言和目标平台，而只需支持Python代码和CPython VM。 尽管如此，CPython编译器的实现是三阶段的。 要了解原因，我们应该更详细地研究三阶段编译器的结构。&lt;/p>&lt;p>&lt;a href="https://laujay.com/img/diagram2.png">图2&lt;/a>&lt;/p>&lt;p>上图是经典编译器的模型。 现在将其与下图中的CPython编译器的体系结构进行比较。&lt;/p>&lt;p>&lt;a href="https://laujay.com/img/diagram3.png">图3&lt;/a>&lt;/p>&lt;p>看起来很相似，不是吗？ 这里的重点是，以前学习过编译器的任何人都应该熟悉CPython编译器的结构。如果没有的话，一本著名的&lt;a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">龙书&lt;/a>是对编译器构造理论的出色介绍。 它很长，但是即使只阅读前几章，您也会从中受益。&lt;/p>&lt;p>我们进行的比较需要提前解释一些东西。 首先，从3.9版本开始，CPython默认使用一个新的解析器，该解析器立即输出AST（抽象语法树），而无需进行构建解析树的中间步骤。 因此，CPython编译器的模型被进一步简化。 其次，与静态编译器的相应阶段相比，CPython编译器的某些现成阶段做得很少，有人可能会说CPython编译器不过是前端。 我们不会采用hardcore compiler 编写者的这种观点。&lt;/p>&lt;h3 id="编译器架构概述">编译器架构概述&lt;/h3>&lt;p>这些图很不错，但是它们隐藏了许多细节并且可能会引起误解，因此让我们花一些时间来讨论CPython编译器的总体设计。&lt;/p>&lt;p>CPython编译器的两个主要组件是：&lt;/p>&lt;ol>&lt;li>前端&lt;/li>&lt;li>后端&lt;/li>&lt;/ol>&lt;p>前端获取Python代码并生成AST。后端获取AST并生成一个代码对象。在整个CPython源代码中，术语“解析器”和“编译器”分别用于前端和后端。这是编译器一词的另一含义。最好将其称为类似代码对象生成器的名称，但是我们会坚持使用编译器，因为它似乎不会造成太多麻烦。&lt;/p>&lt;p>解析器的工作是检查输入是否在语法上正确的Python代码。 如果不是，则解析器报告如下错误：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">12&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">^&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">SyntaxError&lt;/span>: invalid syntax&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果输入正确，将那么解析器将根据语法规则对其进行组织。语法定义语言的语法。 形式语法的概念对于我们的讨论是如此重要，我想我们应该花点时间回顾一下它的正式定义。&lt;/p>&lt;p>根据经典定义，语法是一个包含四个项目的元组：&lt;/p>&lt;ul>&lt;li>Σ – 一组有限的终结符，或简单的终结符（通常用小写字母表示）&lt;/li>&lt;li>N – 一组有限的非终结符号，或简称为非终结符（通常用大写字母表示）。&lt;/li>&lt;li>P – 生成式, 一套生产规则。 对于上下文无关的语法（包括Python语法），生产规则只是从非终结符到任意序列的终结符和非终结符的映射，例如 A→aB。&lt;/li>&lt;li>S – 识别符.&lt;/li>&lt;/ul>&lt;p>文法定义了一种语言，其中包含可以通过应用生成式生成的所有终结符序列。为了生成某个序列，以符号S开头，然后根据生成式将每个非终结符号递归替换为一个序列，直到整个序列由终结符组成。 使用已建立的约定惯例，列出生成式以指定语法就足够了。 例如，这是一个简单的语法，该语法生成交替的一和零的序列:&lt;/p>&lt;p>S→10S|10&lt;/p>&lt;p>当我们更详细地分析解析器时，我们将继续讨论文法。&lt;/p>&lt;h3 id="abstract-syntax-tree">Abstract Syntax Tree&lt;/h3>&lt;p>解析器的最终目标是生成AST。AST是一种树形数据结构，用作源代码的高级表示。这是标准ast模块产生的相应&lt;a href="https://docs.python.org/3/library/ast.html">AST&lt;/a>的一段代码和转储的示例&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">123&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>f(x)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ python -m ast example1.py&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Module&lt;span style="color:#f92672">(&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> body&lt;span style="color:#f92672">=[&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assign&lt;span style="color:#f92672">(&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> targets&lt;span style="color:#f92672">=[&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;x&amp;#39;&lt;/span>, ctx&lt;span style="color:#f92672">=&lt;/span>Store&lt;span style="color:#f92672">())]&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value&lt;span style="color:#f92672">=&lt;/span>Constant&lt;span style="color:#f92672">(&lt;/span>value&lt;span style="color:#f92672">=&lt;/span>123&lt;span style="color:#f92672">))&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Expr&lt;span style="color:#f92672">(&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value&lt;span style="color:#f92672">=&lt;/span>Call&lt;span style="color:#f92672">(&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> func&lt;span style="color:#f92672">=&lt;/span>Name&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;f&amp;#39;&lt;/span>, ctx&lt;span style="color:#f92672">=&lt;/span>Load&lt;span style="color:#f92672">())&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args&lt;span style="color:#f92672">=[&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;x&amp;#39;&lt;/span>, ctx&lt;span style="color:#f92672">=&lt;/span>Load&lt;span style="color:#f92672">())]&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keywords&lt;span style="color:#f92672">=[]))]&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type_ignores&lt;span style="color:#f92672">=[])&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AST节点的类型使用&lt;a href="https://www.cs.princeton.edu/research/techreps/TR-554-97">Zephyr抽象文法定义语言&lt;/a> (ASDL) 。ASDL是一种简单的声明性语言，用于描述树状IR，即AST。这是&lt;a href="https://github.com/python/cpython/blob/master/Parser/Python.asdl">Parser/Python.asdl&lt;/a>中的Assign和Expr节点的定义：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>stmt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">...&lt;/span> &lt;span style="color:#f92672">|&lt;/span> Assign(expr&lt;span style="color:#f92672">*&lt;/span> targets, expr value, string&lt;span style="color:#960050;background-color:#1e0010">?&lt;/span> type_comment) &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#f92672">...&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>expr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">...&lt;/span> &lt;span style="color:#f92672">|&lt;/span> Call(expr func, expr&lt;span style="color:#f92672">*&lt;/span> args, keyword&lt;span style="color:#f92672">*&lt;/span> keywords) &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#f92672">...&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ASDL规范让我们了解了Python AST的样子。但是，解析器需要在C代码中表示AST。幸运的是，从AST节点的ASDL描述中生成C结构很容易。这就是CPython所做的，结果如下所示：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> _stmt {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> _stmt_kind kind;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">union&lt;/span> {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... other kinds of statements&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> asdl_seq &lt;span style="color:#f92672">*&lt;/span>targets;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> expr_ty value;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string type_comment;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } Assign;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... other kinds of statements&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } v;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> lineno;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> col_offset;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> end_lineno;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> end_col_offset;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> _expr {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> _expr_kind kind;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">union&lt;/span> {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... other kinds of expressions&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> expr_ty func;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> asdl_seq &lt;span style="color:#f92672">*&lt;/span>args;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> asdl_seq &lt;span style="color:#f92672">*&lt;/span>keywords;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } Call;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... other kinds of expressions&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } v;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... same as in _stmt&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AST是一种易于使用的表示形式。 它告诉程序做什么，隐藏所有不必要的信息，例如缩进，标点和其他Python的句法特性。&lt;/p>&lt;p>AST表示法的主要受益者之一是编译器， which can walk an AST and emit bytecode in a relatively straightforward manner. 除了编译器之外，许多Python工具都使用AST来处理Python代码。例如，&lt;a href="https://github.com/pytest-dev/pytest/">pytest&lt;/a>在&lt;code>assert&lt;/code>语句失败时，对AST进行更改以提供有用的信息，它本身不执行任何操作，但是如果表达式的计算结果为&lt;code>False&lt;/code>，则会引发&lt;code>AssertionError&lt;/code>。 另一个例子是&lt;a href="https://github.com/PyCQA/bandit">Bandit&lt;/a>，它通过分析AST在Python代码中发现常见的安全问题。&lt;/p>&lt;p>现在，当我们稍微学习了Python AST之后，我们可以看看解析器是如何从源代码中构建它的。&lt;/p>&lt;h3 id="从源代码到ast">从源代码到AST&lt;/h3>&lt;p>事实上，正如我前面所说，从3.9版本开始，CPython的解析器不是一个，而是两个。新的解析器是默认使用的，也可以通过传递&lt;code>-X oldparser&lt;/code>选项来使用旧的解析器。 但在CPython 3.10中，旧的解析器将被完全删除。这两个解析器有很大的不同。我们将重点讨论新的解析器，但在此之前，先讨论一下旧的解析器。&lt;/p>&lt;h4 id="旧的文法分析器">旧的文法分析器&lt;/h4>&lt;p>在很长一段时间里，Python的语法是由生成式文法正式定义的。问题在于，生成式文法并不能直接对应于能够解析这些序列的解析算法。幸运的是，聪明的人已经能够区分出生成文法的类别，并为其建立相应的解析器。这些文法包括&lt;a href="https://en.wikipedia.org/wiki/Context-free_grammar">上下文无关&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/LL_grammar">LL(k)&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/LR_parser">LR(k)&lt;/a>、&lt;a href="https://en.wikipedia.org/wiki/LALR_parser">LALR&lt;/a> 和许多其他类型的文法。Python文法是LL(1)。它使用一种扩展的 Backus-Naur 形式 (&lt;a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF&lt;/a>) 来指定。为了了解如何使用它来描述Python的语法，请看一下while语句的规则。&lt;/p>&lt;pre tabindex="0">&lt;code>file_input: (NEWLINE | stmt)* ENDMARKERstmt: simple_stmt | compound_stmtcompound_stmt: ... | while_stmt | ...while_stmt: &amp;#39;while&amp;#39; namedexpr_test &amp;#39;:&amp;#39; suite [&amp;#39;else&amp;#39; &amp;#39;:&amp;#39; suite]suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT...&lt;/code>&lt;/pre>&lt;p>CPython扩展了传统记法，具有以下特点:&lt;/p>&lt;ul>&lt;li>替代分组: (a | b)&lt;/li>&lt;li>选择部分: [a]&lt;/li>&lt;li>零个或多个和一个或多个重复: a* 和 a+&lt;/li>&lt;/ul>&lt;p>我们可以看到&lt;a href="https://www.blogger.com/profile/12821714508588242516">为什么Guido van Rossum选择使用正则表达式&lt;/a>。它们允许以一种更自然（对程序员来说）的方式来表达编程语言的语法。不写A→aA|a ，我们可以直接写A→a+。这个选择是有代价的。CPython必须开发一种方法来支持扩展符号。&lt;/p>&lt;p>LL(1)文法的解析是一个已解决的问题。解决的方法是作为自上而下的解析器的&lt;a href="https://en.wikipedia.org/wiki/Pushdown_automaton">下推自动机&lt;/a>（PDA）。PDA通过使用栈模拟输入字符串的生成进行操作。为了解析一些输入，它从栈上的起始符号开始。然后，它查看输入中的第一个符号，猜测应该对起始符号应用哪条规则，并将其替换为该规则的右侧。如果栈上的栈顶符号是一个终结符，与输入中的下一个符号相匹配，PDA就会把它出栈并跳过匹配的符号。如果栈顶符号是一个非终结符，PDA会根据输入中的下一个符号，尝试猜测要替换它的规则。这个过程一直重复，直到扫描完整个输入，或者如果PDA无法将栈上的一个终结符与输入中的下一个符号相匹配。后一种情况意味着输入字符串无法被解析。&lt;/p>&lt;p>CPython由于生成式的写法，不能直接使用这种方法，所以必须开发新的方法。&lt;/p>&lt;p>为了支持扩展的符号，旧的解析器用&lt;a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">确定性有限自动机&lt;/a>(DFA)来表示语法的每条规则，DFA以等价于正则表达式而闻名。解析器本身是一个像PDA一样的基于栈的自动机，但它不是在栈上推送符号，而是推送DFA的状态。下面是老解析器使用的关键数据结构。&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> s_state; &lt;span style="color:#75715e">/* State in current DFA */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> dfa &lt;span style="color:#f92672">*&lt;/span>s_dfa; &lt;span style="color:#75715e">/* Current DFA */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> _node &lt;span style="color:#f92672">*&lt;/span>s_parent; &lt;span style="color:#75715e">/* Where to add next node */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} stackentry;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stackentry &lt;span style="color:#f92672">*&lt;/span>s_top; &lt;span style="color:#75715e">/* Top entry */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stackentry s_base[MAXSTACK];&lt;span style="color:#75715e">/* Array of stack entries */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* NB The stack grows down */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} stack;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack p_stack; &lt;span style="color:#75715e">/* Stack of parser states */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> grammar &lt;span style="color:#f92672">*&lt;/span>p_grammar; &lt;span style="color:#75715e">/* Grammar to use */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// basically, a collection of DFAs&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> node &lt;span style="color:#f92672">*&lt;/span>p_tree; &lt;span style="color:#75715e">/* Top of parse tree */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>} parser_state;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还有&lt;a href="https://github.com/python/cpython/blob/3.9/Parser/parser.c">Parser/parser.c&lt;/a>中的注释，总结了这个方法:&lt;/p>&lt;blockquote>&lt;p>一个解析规则用一个确定性有限状态自动机（DFA）来表示。DFA中的一个节点代表解析器的一个状态；一个弧线代表一个过渡。状态迁移要么用终结符标注，要么用非终结符标注。当解析器决定跟随一个标有非终结符的弧线时，它就会被递归调用，以代表该解析规则的DFA作为初始状态；当该DFA接受时，调用它的解析器就会继续。递归调用的解析器构建的解析树作为子树插入到当前的解析树中。&lt;/p>&lt;/blockquote>&lt;p>解析器在解析输入时，会建立一棵解析树，也称为具体语法树（CST）。与AST相反，解析树直接对应于推导输入时应用的规则。解析树中的所有节点都使用同一个节点结构来表示。&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> _node {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">short&lt;/span> n_type;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>n_str;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n_lineno;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n_col_offset;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n_nchildren;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> _node &lt;span style="color:#f92672">*&lt;/span>n_child;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n_end_lineno;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n_end_col_offset;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} node;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然而，一个解析树并不是编译器所期待的。它必须被转换为AST。这项工作是在&lt;a href="https://github.com/python/cpython/blob/3.9/Python/ast.c">Python/ast.c&lt;/a>中完成的，算法是递归地遍历一棵解析树，并将其节点转换成AST节点。几乎没有人觉得这近6000行代码很惊艳。&lt;/p>&lt;h4 id="词法分析器">词法分析器&lt;/h4>&lt;p>从语法的角度来看，Python不是一门简单的语言。不过，Python 文法看起来很简单，包括注释在内，大约可以只有 200 行。这是因为文法的符号是标记而不是单个字符。一个符号由类型来表示，如NUMBER、NAME、NEWLINE、值和在源代码中的位置。CPython区分了63种符号类型，这些类型都列在&lt;a href="https://github.com/python/cpython/blob/3.9/Grammar/Tokens">文法/符号&lt;/a>中。我们可以使用标准的&lt;a href="https://docs.python.org/3/library/tokenize.html">tokenize&lt;/a>模块来查看一个词法分析后的程序的样子。&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">x_plus&lt;/span>(x):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> x &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ python -m tokenize example2.py &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0,0-0,0: ENCODING &lt;span style="color:#e6db74">&amp;#39;utf-8&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1,0-1,3: NAME &lt;span style="color:#e6db74">&amp;#39;def&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1,4-1,10: NAME &lt;span style="color:#e6db74">&amp;#39;x_plus&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1,10-1,11: OP &lt;span style="color:#e6db74">&amp;#39;(&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1,11-1,12: NAME &lt;span style="color:#e6db74">&amp;#39;x&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1,12-1,13: OP &lt;span style="color:#e6db74">&amp;#39;)&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1,13-1,14: OP &lt;span style="color:#e6db74">&amp;#39;:&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1,14-1,15: NEWLINE &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2,0-2,4: INDENT &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2,4-2,6: NAME &lt;span style="color:#e6db74">&amp;#39;if&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2,7-2,8: NAME &lt;span style="color:#e6db74">&amp;#39;x&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2,9-2,11: OP &lt;span style="color:#e6db74">&amp;#39;&amp;gt;=&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2,12-2,13: NUMBER &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2,13-2,14: OP &lt;span style="color:#e6db74">&amp;#39;:&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2,14-2,15: NEWLINE &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3,0-3,8: INDENT &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3,8-3,14: NAME &lt;span style="color:#e6db74">&amp;#39;return&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3,15-3,16: NAME &lt;span style="color:#e6db74">&amp;#39;x&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3,16-3,17: NEWLINE &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4,4-4,4: DEDENT &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4,4-4,10: NAME &lt;span style="color:#e6db74">&amp;#39;return&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4,11-4,12: NUMBER &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4,12-4,13: NEWLINE &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5,0-5,0: DEDENT &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5,0-5,0: ENDMARKER &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span> &lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是该程序在文法解析器中的样子。当文法解析器需要一个符号时，它就会向词法分析器请求一个符号。词法分析器每次从缓冲区中读取一个字符，并尝试将看到的前缀与某种类型的符号进行匹配。词法分析器如何处理不同的编码？它依赖于&lt;code>io&lt;/code>模块。首先，词法分析器检测编码。如果没有指定编码，它默认为UTF-8。然后，词法分析器用 C 调用打开一个文件，相当于 Python 的 &lt;code>open(fd, mode='r', encoding=enc)&lt;/code>，并通过调用&lt;code>readline()&lt;/code>函数读取文件内容。这个函数返回一个unicode字符串。词法分析器读取的字符只是该字符串UTF-8表示的字节（或EOF）。&lt;/p>&lt;p>我们可以直接在文法中定义一个数字或一个名称是什么，尽管这会变得更加复杂。我们不能做的是在文法中表达缩进的意义，而不使其成为&lt;a href="https://en.wikipedia.org/wiki/Context-sensitive_grammar">上下文敏感的&lt;/a>，因此，缩进不适合解析。词法分析器通过提供 &lt;code>INDENT &lt;/code>和 &lt;code>DEDENT &lt;/code>符号，使解析器的工作变得更加容易。它们的意思就是像 C 语言中大括号的意思。词法分析器有足够的能力来处理缩进，因为它有状态。当前的缩进级别被保存在栈的顶部。当级别增加时，它的缩进会被推送到栈上。如果级别降低，所有更高的级别都会从堆栈中弹出。&lt;/p>&lt;p>旧的文法分析器是CPython代码库中的一个不小的部分。文法的DFA是自动生成的，但文法分析器的其他部分是手工编写的。这与新的文法分析器形成鲜明对比，新的文法分析器似乎是解决Python代码解析问题的一个更优雅的方案。&lt;/p>&lt;h4 id="新的文法分析器">新的文法分析器&lt;/h4>&lt;p>新的解析器带有新的文法。该文法法为&lt;a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">解析表达语法&lt;/a>（PEG）。要明白的是，PEG不仅仅是一类文法。 这是另一种定义文法的方式。PEGs是&lt;a href="https://pdos.csail.mit.edu/~baford/packrat/popl04/">由Bryan Ford在2004年提出的&lt;/a>，作为描述一种编程语言并根据描述生成解析器的工具 。PEG与传统的形式化文法不同的是，它的规则将非终结符映射到解析表达式上，而不仅仅是符号序列。 这与CPython的理念是一致的。 解析表达式是归纳性定义的。 如果e、e1和e2是解析表达式, 那就意味着它是:&lt;/p>&lt;ol>&lt;li>空字符串&lt;/li>&lt;li>任何终结符&lt;/li>&lt;li>任何非终结符&lt;/li>&lt;li>e1e2, 一个序列&lt;/li>&lt;li>e1/e2, 优先选择&lt;/li>&lt;li>e∗, 零次或多次重复&lt;/li>&lt;li>!e, 非谓词&lt;/li>&lt;/ol>&lt;p>PEGs是分析文法，这意味着它们不仅可以生成语言，还可以分析它们。Ford将解析表达式e识别输入x的含义形式化，基本上，任何用某个解析表达式识别输入的尝试，要么成功，要么失败, 消费掉输入x或者不消费。例如，将解析表达式a应用于输入ab的结果是成功，并消费掉a。&lt;/p>&lt;p>这种形式化允许将任何PEG转换为&lt;a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">递归下降解析器&lt;/a> 。递归下降解析器将文法的每个非终结符与解析函数相关联。 对于PEG来说，解析函数的功能是相应解析表达式的实现。 如果解析表达式包含非终结符，则将其递归调用其解析函数。&lt;/p>&lt;p>一个非终结符可能有多个产生规则。递归下降解析器必须决定哪一个是用来推导输入的。如果一个文法是LL(k)，一个解析器可以查看输入中的下一个k个字符，并预测正确的规则。这样的解析器称为预测性解析器。如果无法预测，则采用回溯法。采用回溯法的解析器会尝试一条规则，如果失败，则回溯并尝试另一条规则。这正是PEG中优先选择操作符的作用。所以，PEG解析器是一个带回溯的递归下降解析器。&lt;/p>&lt;p>回溯方法功能强大，但计算成本很高。 考虑一个简单的例子。 我们将表达式AB/A 应用于在A上成功但在B上失败的输入。根据对优先选择运算符的解释，解析器首先尝试识别A，成功，然后尝试识别B。失败后再尝试识别A。由于这样的冗余计算，解析时间可能是输入大小的指数。为了解决这个问题, &lt;a href="https://bford.info/pub/lang/packrat-icfp02/">Ford suggested&lt;/a> 使用记忆技术，即缓存函数调用的结果。使用此技术，可以保证解析器（称为packrat解析器）可以在线性时间内工作，但要消耗更多的内存。 这就是CPython的新解析器所做的。 这是一个packrat解析器！&lt;/p>&lt;p>无论新的解析器有多好，都必须给出替换旧解析器的理由。这就是PEPs的作用。 &lt;a href="https://www.python.org/dev/peps/pep-0617/">PEP 617 &amp;ndash; New PEG parser for CPython&lt;/a> 给出了新旧解析器的背景，并解释了过渡背后的原因。简而言之，新的解析器取消了对语法的LL(1)限制，应该更容易维护。Guido van Rossum 写了 &lt;a href="https://medium.com/@gvanrossum_83706/peg-parsing-series-de5d41b2ed60">一个系列关于PEG解析的优秀文章&lt;/a>, 在这写文章里他详细介绍了如何实现一个简单的PEG解析器。接下来，我们将看看它的CPython实现。&lt;/p>&lt;p>您可能会惊讶地发现，&lt;a href="https://github.com/python/cpython/blob/3.9/Grammar/python.gram">新的文法文件&lt;/a>比旧的大了三倍多。这是因为新的文法不仅仅是一个文法，而是一个&lt;a href="https://en.wikipedia.org/wiki/Syntax-directed_translation">语法导向翻译方案&lt;/a>(SDTS)。SDTS是一个在规则上附加了动作的文法。一个动作是一段代码。当解析器将相应的规则应用于输入并成功时，它就会执行一个动作。CPython在解析时使用action来构建AST。要想知道是怎么做的，我们来看看新的语法是什么样子的。我们已经看到了旧语法的while语句的规则，所以这里是它们的新样子。&lt;/p>&lt;pre tabindex="0">&lt;code>file[mod_ty]: a=[statements] ENDMARKER { _PyPegen_make_module(p, a) }statements[asdl_seq*]: a=statement+ { _PyPegen_seq_flatten(p, a) }statement[asdl_seq*]: a=compound_stmt { _PyPegen_singleton_seq(p, a) } | simple_stmtcompound_stmt[stmt_ty]: | ... | &amp;amp;&amp;#39;while&amp;#39; while_stmtwhile_stmt[stmt_ty]: | &amp;#39;while&amp;#39; a=named_expression &amp;#39;:&amp;#39; b=block c=[else_block] { _Py_While(a, b, c, EXTRA) }...&lt;/code>&lt;/pre>&lt;p>每个规则都以非终结符的名称开头。 解析函数返回结果的C类型。 右侧是解析表达式。 花括号中的代码表示一个动作。 动作是返回AST节点或其字段的简单函数调用。&lt;/p>&lt;p>新的解析器是&lt;a href="https://github.com/python/cpython/blob/3.9/Parser/pegen/parse.c">Parser/pegen / parse.c&lt;/a>。它由解析器生成器自动生成。解析器生成器是用Python编写的。这是一个用C或Python获取语法并生成PEG解析器的程序。文法在文法文件中描述，并由&lt;code>Grammar&lt;/code>类的实例表示。要创建这样的实例，文法文件必须有一个解析器。 &lt;a href="https://github.com/python/cpython/blob/3.9/Tools/peg_generator/pegen/grammar_parser.py">此解析器&lt;/a>也是由解析器生成器自动从&lt;a href="https://github.com/python/cpython/blob/3.9/Tools/peg_generator/pegen/grammar_parser.py">metagrammar&lt;/a>。这就是解析器生成器可以在Python中生成解析器的原因。但是解析metagrammar的是什么呢？好吧，它与语法的符号相同，因此生成的文法解析器也能够解析metagrammar。当然，文法分析器必须是自举的，第一个版本必须是手工编写的。完成后，所有解析器都可以自动生成。&lt;/p>&lt;p>与旧的解析器一样，新的解析器从词法分析器获取符号。 对于PEG解析器而言，这是特殊的，因为它可以统一标记和解析。 直到我们看到了tokenizer所做的非凡的工作，因此CPython开发人员决定使用它。&lt;/p>&lt;p>到此为止，我们结束了对解析的讨论，接下来看下AST。&lt;/p>&lt;h3 id="ast-优化">AST 优化&lt;/h3>&lt;p>CPython编译器的架构图向我们展示了AST优化器与解析器和编译器并列。这可能过分强调了优化器的作用。AST优化器只是常量折叠， 其在CPython3.7中才被引入。在CPython3.7之前， 常量折叠是在后期由窥孔优化完成的。尽管如此，由于AST优化器的存在，我们可以写出这样的东西。&lt;/p>&lt;pre tabindex="0">&lt;code>n = 2 ** 32 # easier to write and to read&lt;/code>&lt;/pre>&lt;p>并希望在编译时计算出来。&lt;/p>&lt;p>一个不太明显的优化的例子是将一个常数列表和一个常数集合分别转换为一个元组和一个frozenset。当在 &lt;code>in&lt;/code> 或 &lt;code>not in &lt;/code> 右侧使用一个list或者set时，就会进行这种优化。&lt;/p>&lt;h3 id="从ast到代码对象">从AST到代码对象&lt;/h3>&lt;p>到目前为止，我们一直在研究CPython是如何从源代码中创建AST的，但正如我们在第一篇文章中看到的，CPython虚拟机对AST一无所知，只能执行一个代码对象。将AST转换为代码对象是编译器的工作。更具体地说，编译器必须返回模块的代码对象，其中包含模块的字节码以及模块中其他代码块的代码对象，如定义的函数和类。&lt;/p>&lt;p>有时候，理解解决问题的最好方法是自己的思考。让我们思考一下，如果我们是编译器，我们会怎么做？.我们从代表一个模块的AST的根节点开始。该节点的子节点为语句。让我们假设第一条语句是一个简单的赋值，如&lt;code>x = 1&lt;/code>。它由&lt;code>Assign&lt;/code>AST节点表示: &lt;code>Assign(targets=[Name(id='x', ctx=Store())], value=Constant(value=1))&lt;/code>. 为了将这个节点转换为代码对象，我们需要创建一个代码对象，将常量&lt;code>1&lt;/code>存储在代码对象的常量列表中，将变量&lt;code>x&lt;/code>的名字存储在代码对象的名称列表中，并发出&lt;code>LOAD_CONST&lt;/code>和&lt;code>STORE_NAME&lt;/code>指令。 我们可以写一个函数来做这件事。但即使是一个简单的任务也可能很棘手。 例如，想象一下，在一个函数体内进行同样的赋值。I如果&lt;code>x&lt;/code>是一个局部变量，我们应该发出&lt;code>STORE_FAST&lt;/code>指令。 如果&lt;code>x&lt;/code>是一个全局变量，我们应该发出&lt;code>STORE_GLOBAL&lt;/code>指令。 最后，如果&lt;code>x&lt;/code>被一个嵌套函数所引用，我们应该发出&lt;code>STORE_DEREF&lt;/code>指令。问题是要确定变量&lt;code>x&lt;/code>的类型是什么。CPython通过在编译前建立一个符号表来解决这个问题。&lt;/p>&lt;h4 id="符号表">符号表&lt;/h4>&lt;p>符号表中包含关于代码块和所使用的符号的信息。它由一个&lt;code>symtable&lt;/code>结构体和一个&lt;code>symtable_entry&lt;/code>结构体的集合表示，程序中的每个代码块都有一个。一个符号表项包含了一个代码块的属性，包括它的名字、它的类型（模块、类或函数）和一个字典，它将代码块中使用的变量名称映射到表示其范围和用途的标志上。以下是&lt;code>_symtable_entry&lt;/code> 结构体的完整定义：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> _symtable_entry {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject_HEAD&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>ste_id; &lt;span style="color:#75715e">/* int: key in ste_table-&amp;gt;st_blocks */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>ste_symbols; &lt;span style="color:#75715e">/* dict: variable names to flags */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>ste_name; &lt;span style="color:#75715e">/* string: name of current block */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>ste_varnames; &lt;span style="color:#75715e">/* list of function parameters */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>ste_children; &lt;span style="color:#75715e">/* list of child blocks */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>ste_directives;&lt;span style="color:#75715e">/* locations of global and nonlocal statements */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _Py_block_ty ste_type; &lt;span style="color:#75715e">/* module, class, or function */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ste_nested; &lt;span style="color:#75715e">/* true if block is nested */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> ste_free : &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">/* true if block has free variables */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> ste_child_free : &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">/* true if a child block has free vars,&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> including free refs to globals */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> ste_generator : &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">/* true if namespace is a generator */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> ste_coroutine : &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">/* true if namespace is a coroutine */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> ste_comprehension : &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">/* true if namespace is a list comprehension */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> ste_varargs : &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">/* true if block has varargs */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> ste_varkeywords : &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">/* true if block has varkeywords */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> ste_returns_value : &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">/* true if namespace uses return with&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> an argument */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> ste_needs_class_closure : &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">/* for class scopes, true if a&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> closure over __class__&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> should be created */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> ste_comp_iter_target : &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">/* true if visiting comprehension target */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ste_comp_iter_expr; &lt;span style="color:#75715e">/* non-zero if visiting a comprehension range expression */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ste_lineno; &lt;span style="color:#75715e">/* first line of block */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ste_col_offset; &lt;span style="color:#75715e">/* offset of first line of block */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ste_opt_lineno; &lt;span style="color:#75715e">/* lineno of last exec or import * */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ste_opt_col_offset; &lt;span style="color:#75715e">/* offset of last exec or import * */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> symtable &lt;span style="color:#f92672">*&lt;/span>ste_table;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} PySTEntryObject;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CPython使用术语命名空间作为符号表背景下代码块的同义词。因此，我们可以说，符号表项是对命名空间的描述。符号表项通过&lt;code>ste_children&lt;/code>字段形成程序中所有命名空间的层次结构，该字段是一个子命名空间的列表。我们可以使用标准库中的&lt;a href="https://docs.python.org/3/library/symtable.html#module-symtable">&lt;code>symtable&lt;/code>&lt;/a>模块来探索这个层次结构&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># example3.py&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span>(x):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lc &lt;span style="color:#f92672">=&lt;/span> [x&lt;span style="color:#f92672">+&lt;/span>i &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">10&lt;/span>)]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> lc&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#f92672">from&lt;/span> symtable &lt;span style="color:#f92672">import&lt;/span> symtable&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> f &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#39;example3.py&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> st &lt;span style="color:#f92672">=&lt;/span> symtable(f&lt;span style="color:#f92672">.&lt;/span>read(), &lt;span style="color:#e6db74">&amp;#39;example3.py&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;exec&amp;#39;&lt;/span>) &lt;span style="color:#75715e"># module&amp;#39;s symtable entry&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> dir(st)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#f92672">...&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;get_children&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;get_id&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;get_identifiers&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;get_lineno&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;get_name&amp;#39;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;get_symbols&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;get_type&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;has_children&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;is_nested&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;is_optimized&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;lookup&amp;#39;&lt;/span>]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> st&lt;span style="color:#f92672">.&lt;/span>get_children()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#f92672">&amp;lt;&lt;/span>Function SymbolTable &lt;span style="color:#66d9ef">for&lt;/span> func &lt;span style="color:#f92672">in&lt;/span> example3&lt;span style="color:#f92672">.&lt;/span>py&lt;span style="color:#f92672">&amp;gt;&lt;/span>]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> func_st &lt;span style="color:#f92672">=&lt;/span> st&lt;span style="color:#f92672">.&lt;/span>get_children()[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#75715e"># func&amp;#39;s symtable entry&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> func_st&lt;span style="color:#f92672">.&lt;/span>get_children()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#f92672">&amp;lt;&lt;/span>Function SymbolTable &lt;span style="color:#66d9ef">for&lt;/span> listcomp &lt;span style="color:#f92672">in&lt;/span> example3&lt;span style="color:#f92672">.&lt;/span>py&lt;span style="color:#f92672">&amp;gt;&lt;/span>]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> lc_st &lt;span style="color:#f92672">=&lt;/span> func_st&lt;span style="color:#f92672">.&lt;/span>get_children()[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#75715e"># list comprehension&amp;#39;s symtable entry&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> lc_st&lt;span style="color:#f92672">.&lt;/span>get_symbols()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#f92672">&amp;lt;&lt;/span>symbol &lt;span style="color:#e6db74">&amp;#39;.0&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>, &lt;span style="color:#f92672">&amp;lt;&lt;/span>symbol &lt;span style="color:#e6db74">&amp;#39;i&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>, &lt;span style="color:#f92672">&amp;lt;&lt;/span>symbol &lt;span style="color:#e6db74">&amp;#39;x&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> x_sym &lt;span style="color:#f92672">=&lt;/span> lc_st&lt;span style="color:#f92672">.&lt;/span>get_symbols()[&lt;span style="color:#ae81ff">2&lt;/span>]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> dir(x_sym)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#f92672">...&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;get_name&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;get_namespace&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;get_namespaces&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;is_annotated&amp;#39;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;is_assigned&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;is_declared_global&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;is_free&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;is_global&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;is_imported&amp;#39;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;is_local&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;is_namespace&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;is_nonlocal&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;is_parameter&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;is_referenced&amp;#39;&lt;/span>]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> x_sym&lt;span style="color:#f92672">.&lt;/span>is_local(), x_sym&lt;span style="color:#f92672">.&lt;/span>is_free()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">False&lt;/span>, &lt;span style="color:#66d9ef">True&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个例子表明，每个代码块都有一个相应的符号表项。我们在列表推导式的命名空间内意外地遇到了奇怪的&lt;code>.0&lt;/code>符号。这个命名空间并不包含&lt;code>range&lt;/code>符号，这也很奇怪。这是因为列表推导式被实现为一个匿名函数，&lt;code>range(10)&lt;/code>被作为一个参数传递给它。这个参数的引用是&amp;quot;.0&amp;quot;。CPython还隐藏了什么黑盒？&lt;/p>&lt;p>符号表项是分两次构建的。在第一遍中，CPython遍历AST，为它遇到的每个代码块创建一个符号表项。它也会收集一些可以当场收集的信息，比如一个符号是否在该块中被定义或使用。但有些信息在第一遍时很难推导出来。考虑一下这个例子：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">top&lt;/span>():&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">nested&lt;/span>():&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在为&lt;code>nested()&lt;/code>函数构建符号表项时，我们无法判断&lt;code>x&lt;/code>是全局变量还是自由变量，即在&lt;code>top()&lt;/code>函数中定义，因为我们还没有看到赋值。&lt;/p>&lt;p>Python通过做第二遍遍历来解决这个问题。在第二遍的开始，我们已经知道了符号的定义和使用。缺少的信息通过从顶部开始递归访问所有的符号表项来填补。在&lt;code>nested&lt;/code>闭包函数的同层定义的符号被向下传递到&lt;code>nested&lt;/code>的命名空间，而&lt;code>nested&lt;/code>闭包函数内的作用域中自由变量的名字被传递回来。&lt;/p>&lt;p>符号表项是用&lt;code>symtable&lt;/code>结构管理的。它既用来构建符号表项，也用来在编译过程中访问它们。让我们看一下它的定义:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> symtable {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>st_filename; &lt;span style="color:#75715e">/* name of file being compiled,&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> decoded from the filesystem encoding */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> _symtable_entry &lt;span style="color:#f92672">*&lt;/span>st_cur; &lt;span style="color:#75715e">/* current symbol table entry */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> _symtable_entry &lt;span style="color:#f92672">*&lt;/span>st_top; &lt;span style="color:#75715e">/* symbol table entry for module */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>st_blocks; &lt;span style="color:#75715e">/* dict: map AST node addresses&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * to symbol table entries */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>st_stack; &lt;span style="color:#75715e">/* list: stack of namespace info */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>st_global; &lt;span style="color:#75715e">/* borrowed ref to st_top-&amp;gt;ste_symbols */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> st_nblocks; &lt;span style="color:#75715e">/* number of blocks used. kept for&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> consistency with the corresponding&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> compiler structure */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>st_private; &lt;span style="color:#75715e">/* name of current class or NULL */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyFutureFeatures &lt;span style="color:#f92672">*&lt;/span>st_future; &lt;span style="color:#75715e">/* module&amp;#39;s future features that affect&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> the symbol table */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> recursion_depth; &lt;span style="color:#75715e">/* current recursion depth */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> recursion_limit; &lt;span style="color:#75715e">/* recursion limit */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要注意的重要字段是&lt;code>st_stack&lt;/code>和&lt;code>st_blocks&lt;/code>。&lt;code>st_stack&lt;/code>字段是一个符号表项的堆栈。在构建符号表的第一遍过程中，CPython在进入相应的代码块时将一个条目推入堆栈，在退出相应的代码块时从堆栈中弹出一个条目。&lt;code>st_blocks&lt;/code>字段是一个字典，编译器用它来获取一个给定AST节点的符号表条目。&lt;code>st_cur&lt;/code>和&lt;code>st_top&lt;/code>字段也很重要，但它们的含义应该是显而易见的。&lt;/p>&lt;p>要了解更多关于符号表及其构造的信息，我强烈推荐你&lt;a href="https://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1">Eli Bendersky的文章&lt;/a>&lt;/p>&lt;h4 id="基本块">基本块&lt;/h4>&lt;p>符号表可以帮助我们翻译涉及变量的语句，如&lt;code>x = 1&lt;/code>。但如果我们试图翻译一个更复杂的控制流语句，就会出现新的问题。考虑一下另一段隐晦的代码:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> x &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">or&lt;/span> x &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">17&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">...&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>相应的AST子树有如下结构：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">If&lt;/span>(&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#a6e22e">BoolOp&lt;/span>(...),&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> body&lt;span style="color:#f92672">=&lt;/span>[...],&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> orelse&lt;span style="color:#f92672">=&lt;/span>[...]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而编译器将其编译成以下字节码:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> LOAD_NAME &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>x&lt;span style="color:#f92672">)&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>0&lt;span style="color:#f92672">)&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4&lt;/span> COMPARE_OP &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">(==)&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">6&lt;/span> POP_JUMP_IF_TRUE &lt;span style="color:#ae81ff">16&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">8&lt;/span> LOAD_NAME &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>x&lt;span style="color:#f92672">)&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">10&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">(&lt;/span>17&lt;span style="color:#f92672">)&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">12&lt;/span> COMPARE_OP &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&amp;gt;&lt;span style="color:#f92672">)&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">14&lt;/span> POP_JUMP_IF_FALSE &lt;span style="color:#ae81ff">22&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> &amp;gt;&amp;gt; &lt;span style="color:#ae81ff">16&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">(&lt;/span>True&lt;span style="color:#f92672">)&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">18&lt;/span> STORE_NAME &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">(&lt;/span>y&lt;span style="color:#f92672">)&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">20&lt;/span> JUMP_FORWARD &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#f92672">(&lt;/span>to 26&lt;span style="color:#f92672">)&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> &amp;gt;&amp;gt; &lt;span style="color:#ae81ff">22&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">(&lt;/span>False&lt;span style="color:#f92672">)&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">24&lt;/span> STORE_NAME &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">(&lt;/span>y&lt;span style="color:#f92672">)&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">5&lt;/span> &amp;gt;&amp;gt; &lt;span style="color:#ae81ff">26&lt;/span> ...&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该字节码是线性的。&lt;code>test&lt;/code>节点的指令应该放在最前面，&lt;code>body&lt;/code>块的指令应该放在&lt;code>orelse&lt;/code>块的指令前面。控制流语句的问题是它们涉及到跳转，而跳转往往是在它所指向的指令之前发出的。在我们的例子中，如果第一次测试成功，我们想直接跳到第一条&lt;code>body&lt;/code> 指令，但我们还不知道它应该在哪里。如果第二次测试失败，我们必须跳过&lt;code>body&lt;/code>块到&lt;code>orelse&lt;/code>块，但是第一条&lt;code>orelse&lt;/code>指令的位置只有在我们编译了&lt;code>body&lt;/code>块之后才会知道。&lt;/p>&lt;p>如果我们把每个区块的指令移到一个单独的数据结构中，就可以解决这个问题。然后，我们不再把跳转目标指定为字节码中的具体位置，而是指向这些数据结构。最后，当所有的块都被编译出来并且知道它们的大小时，我们就可以计算跳转的参数并将这些块组装成一个单一的指令序列。这就是编译器所做的。&lt;/p>&lt;p>我们正在谈论的块被称为基本块。它们不是CPython所特有的，尽管CPython的基本块概念与传统的定义不同。根据龙书的定义，一个基本块是一个最大的指令序列，应该如下:&lt;/p>&lt;p>​1.控制只能进入该块的第一条指令；以及​ 2.控制在离开该块时没有停止或分支，可能在最后一条指令时除外。&lt;/p>&lt;p>CPython放弃了第二个。换句话说，除了第一条指令，基本块中的任何指令都不能成为跳转的目标，但基本块本身可以包含跳转指令。为了编译我们例子中的AST，编译器创建了四个基本块:&lt;/p>&lt;ol>&lt;li>指令 0-14 对应 &lt;code>test&lt;/code>&lt;/li>&lt;li>指令 16-20 对应 &lt;code>body&lt;/code>&lt;/li>&lt;li>指令 22-24 对应 &lt;code>orelse&lt;/code>; 最后&lt;/li>&lt;li>指令 26-&amp;hellip; 为if语句之后的任何内容&lt;/li>&lt;/ol>&lt;p>一个基本块由 &lt;code>basicblock_&lt;/code>结构表示，其定义如下:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> basicblock_ {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Each basicblock in a compilation unit is linked via b_list in the&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> reverse order that the block are allocated. b_list points to the next&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> block, not to be confused with b_next, which is next by control flow. */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> basicblock_ &lt;span style="color:#f92672">*&lt;/span>b_list;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* number of instructions used */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> b_iused;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* length of instruction array (b_instr) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> b_ialloc;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* pointer to an array of instructions, initially NULL */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> instr &lt;span style="color:#f92672">*&lt;/span>b_instr;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* If b_next is non-NULL, it is a pointer to the next&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> block reached by normal control flow. */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> basicblock_ &lt;span style="color:#f92672">*&lt;/span>b_next;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* b_seen is used to perform a DFS of basicblocks. */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> b_seen : &lt;span style="color:#ae81ff">1&lt;/span>;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* b_return is true if a RETURN_VALUE opcode is inserted. */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> b_return : &lt;span style="color:#ae81ff">1&lt;/span>;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* depth of stack upon entry of block, computed by stackdepth() */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> b_startdepth;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* instruction offset for block, computed by assemble_jump_offsets() */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> b_offset;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} basicblock;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面是 &lt;code>instr &lt;/code>结构的定义:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> instr {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> i_jabs : &lt;span style="color:#ae81ff">1&lt;/span>;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> i_jrel : &lt;span style="color:#ae81ff">1&lt;/span>;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> i_opcode;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i_oparg;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> basicblock_ &lt;span style="color:#f92672">*&lt;/span>i_target; &lt;span style="color:#75715e">/* target block (if jump instruction) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i_lineno;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看到，基本块不仅通过跳转指令连接，而且还通过&lt;code>b_list&lt;/code>和&lt;code>b_next&lt;/code>字段连接。编译器使用&lt;code>b_list&lt;/code>来访问所有分配的块，例如，释放内存。&lt;code>b_next&lt;/code>字段是我们现在更感兴趣的。正如注释所说，它指向正常控制流到达的下一个块，这意味着它可以被用来以正确的顺序组装块。再次回到我们的例子，&lt;code>test&lt;/code>块指向&lt;code>body&lt;/code>块，&lt;code>body&lt;/code>块指向&lt;code>orelse&lt;/code>块，&lt;code>orelse&lt;/code>块指向if语句之后的块。由于基本块相互指向，它们形成一个图，称为&lt;a href="https://en.wikipedia.org/wiki/Control-flow_graph">控制流图&lt;/a>(CFG)&lt;/p>&lt;h4 id="frame-blocks">frame blocks&lt;/h4>&lt;p>还有一个问题需要解决：在编译 &amp;ldquo;continue &amp;ldquo;和 &amp;ldquo;break &amp;ldquo;等语句时，如何理解跳转到哪里？编译器通过引入另一种类型的块，即frame块来解决这个问题。有不同种类的frame块。例如，&lt;code>WHILE_LOOP&lt;/code> frame块指向两个基本块：&lt;code>body&lt;/code>块和while语句后的块。这些基本块分别在编译&lt;code>continue&lt;/code>和&lt;code>break&lt;/code>语句时使用。由于frame块可以嵌套，编译器使用堆栈对其进行跟踪，每个代码块有一个frame块堆栈。在处理&lt;code>try-except-finally&lt;/code>等语句时，frame块也很有用，但我们现在不会纠缠于此。让我们来看看 &lt;code>fblockinfo &lt;/code> 结构的定义。&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> fblocktype { WHILE_LOOP, FOR_LOOP, EXCEPT, FINALLY_TRY, FINALLY_END,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WITH, ASYNC_WITH, HANDLER_CLEANUP, POP_VALUE };&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> fblockinfo {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> fblocktype fb_type;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> basicblock &lt;span style="color:#f92672">*&lt;/span>fb_block;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* (optional) type-specific exit or cleanup block */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> basicblock &lt;span style="color:#f92672">*&lt;/span>fb_exit;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* (optional) additional information required for unwinding */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>fb_datum;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们已经揭示了三个重要的问题，我们也看到了编译器是如何解决这些问题的。现在，让我们把所有东西放在一起，看看编译器是如何从头到尾工作的。&lt;/p>&lt;h4 id="编译单元编译器和汇编器">编译单元、编译器和汇编器&lt;/h4>&lt;p>正如我们已经发现的，在建立符号表之后，编译器还要执行两个步骤，将AST转换为代码对象:&lt;/p>&lt;ol>&lt;li>它创建了一个基本块的CFG；以及&lt;/li>&lt;li>它将一个CFG汇编成一个代码对象&lt;/li>&lt;/ol>&lt;p>这个两步过程是针对程序中的每个代码块进行的。编译器从建立模块的CFG开始，最后将模块的CFG汇编成模块的代码对象。在这之间，它通过递归调用&lt;code>compiler_visit_*&lt;/code>和&lt;code>compiler_*&lt;/code>函数来遍历AST，其中&lt;code>*&lt;/code>表示被访问或编译的内容。例如，&lt;code>compiler_visit_stmt&lt;/code>将给定语句的编译委托给适当的&lt;code>compiler_*&lt;/code>函数，而&lt;code>compiler_if&lt;/code>函数知道如何编译&lt;code>If&lt;/code>AST节点。如果一个节点引入了新的基本块，编译器会创建它们。如果一个节点开始了一个代码块，编译器会创建一个新的编译单元并进入该单元。编译单元是一个数据结构，它捕获了代码块的编译状态。它作为代码对象的一个可变的原型，并指向一个新的CFG。编译器在退出开始当前代码块的节点时，会汇编这个CFG。汇编后的代码对象被保存在父编译单元中。像往常一样，我鼓励你看一下结构定义:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> compiler_unit {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PySTEntryObject &lt;span style="color:#f92672">*&lt;/span>u_ste;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>u_name;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>u_qualname; &lt;span style="color:#75715e">/* dot-separated qualified name (lazy) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> u_scope_type;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* The following fields are dicts that map objects to&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> the index of them in co_XXX. The index is used as&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> the argument for opcodes that refer to those collections.&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>u_consts; &lt;span style="color:#75715e">/* all constants */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>u_names; &lt;span style="color:#75715e">/* all names */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>u_varnames; &lt;span style="color:#75715e">/* local variables */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>u_cellvars; &lt;span style="color:#75715e">/* cell variables */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>u_freevars; &lt;span style="color:#75715e">/* free variables */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>u_private; &lt;span style="color:#75715e">/* for private name mangling */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Py_ssize_t u_argcount; &lt;span style="color:#75715e">/* number of arguments for block */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Py_ssize_t u_posonlyargcount; &lt;span style="color:#75715e">/* number of positional only arguments for block */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Py_ssize_t u_kwonlyargcount; &lt;span style="color:#75715e">/* number of keyword only arguments for block */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Pointer to the most recently allocated block. By following b_list&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> members, you can reach all early allocated blocks. */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> basicblock &lt;span style="color:#f92672">*&lt;/span>u_blocks;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> basicblock &lt;span style="color:#f92672">*&lt;/span>u_curblock; &lt;span style="color:#75715e">/* pointer to current block */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> u_nfblocks;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> fblockinfo u_fblock[CO_MAXBLOCKS];&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> u_firstlineno; &lt;span style="color:#75715e">/* the first lineno of the block */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> u_lineno; &lt;span style="color:#75715e">/* the lineno for the current stmt */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> u_col_offset; &lt;span style="color:#75715e">/* the offset of the current stmt */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另一个对编译至关重要的数据结构是 &lt;code>compiler&lt;/code>结构，它表示编译的全局状态。下面是它的定义:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> compiler {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>c_filename;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> symtable &lt;span style="color:#f92672">*&lt;/span>c_st;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyFutureFeatures &lt;span style="color:#f92672">*&lt;/span>c_future; &lt;span style="color:#75715e">/* pointer to module&amp;#39;s __future__ */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyCompilerFlags &lt;span style="color:#f92672">*&lt;/span>c_flags;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> c_optimize; &lt;span style="color:#75715e">/* optimization level */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> c_interactive; &lt;span style="color:#75715e">/* true if in interactive mode */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> c_nestlevel;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> c_do_not_emit_bytecode; &lt;span style="color:#75715e">/* The compiler won&amp;#39;t emit any bytecode&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> if this value is different from zero.&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> This can be used to temporarily visit&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> nodes without emitting bytecode to&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> check only errors. */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>c_const_cache; &lt;span style="color:#75715e">/* Python dict holding all constants,&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> including names tuple */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> compiler_unit &lt;span style="color:#f92672">*&lt;/span>u; &lt;span style="color:#75715e">/* compiler state for current block */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>c_stack; &lt;span style="color:#75715e">/* Python list holding compiler_unit ptrs */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyArena &lt;span style="color:#f92672">*&lt;/span>c_arena; &lt;span style="color:#75715e">/* pointer to memory allocation arena */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而定义前面的注释解释了两个最重要的字段是什么，是为了什么:&lt;/p>&lt;blockquote>&lt;p>u指针指向当前的编译单元，而enclosing的单元则存储在c_stack中。u和c_stack由compiler_enter_scope()和compiler_exit_scope()管理。&lt;/p>&lt;/blockquote>&lt;p>为了将基本块组装成一个代码对象，编译器首先要通过将指针替换成字节码中的位置来修复跳转指令。一方面，这是一个简单的任务，因为所有的基本块的大小是已知的。另外一方面，当我们修复一个跳转的时候，基本块的大小可能会发生变化。目前的解决方案是，在大小发生变化的时候，在一个循环中不断修复跳转。下面是源代码中对这个解决方案的一个注释：&lt;/p>&lt;blockquote>&lt;p>这是一个可怕的hack，可能会损失性能，但是从好的方面看，在我们想出更好的解决方案前，他是可以工作的。&lt;/p>&lt;/blockquote>&lt;p>剩下的就很简单了。编译器对基本块进行迭代并发出指令。进展被保存在 &lt;code>assembler&lt;/code> 的结构中:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> assembler {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>a_bytecode; &lt;span style="color:#75715e">/* string containing bytecode */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a_offset; &lt;span style="color:#75715e">/* offset into bytecode */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a_nblocks; &lt;span style="color:#75715e">/* number of reachable blocks */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> basicblock &lt;span style="color:#f92672">**&lt;/span>a_postorder; &lt;span style="color:#75715e">/* list of blocks in dfs postorder */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>a_lnotab; &lt;span style="color:#75715e">/* string containing lnotab */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a_lnotab_off; &lt;span style="color:#75715e">/* offset into lnotab */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a_lineno; &lt;span style="color:#75715e">/* last lineno of emitted instruction */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a_lineno_off; &lt;span style="color:#75715e">/* bytecode offset of last lineno */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这一点上，当前的编译单元和汇编器包含了创建一个代码对象所需的所有数据。祝贺你! 我们几乎完成了!&lt;/p>&lt;h4 id="peephole-optimizer">peephole optimizer&lt;/h4>&lt;p>创建代码对象的最后一步是优化字节码。这是peephole optimizer的工作。下面是它所执行的一些优化类型:&lt;/p>&lt;ul>&lt;li>像语句 &lt;code>if True: ...&lt;/code> 和 &lt;code>while True: ...&lt;/code> 生成一个由 &lt;code>LOAD_CONST trueconst&lt;/code> 和 &lt;code>POP_JUMP_IF_FALSE&lt;/code> 指令组成的序列。 peephole optimizer 消除了这种指令。&lt;/li>&lt;li>像语句 &lt;code>a, = b,&lt;/code> 会构建元组的字节码，然后解包它。peephole optimizer用一个简单的赋值来取代它。&lt;/li>&lt;li>peephole optimizer会删除 &lt;code>RETURN&lt;/code> 之后永远不会执行的指令。&lt;/li>&lt;/ul>&lt;p>本质上，peephole optimizer删除了多余的指令，从而使字节码更加紧凑。在字节码被优化后，编译器创建了代码对象，而虚拟机则准备执行它。&lt;/p>&lt;h3 id="summary">Summary&lt;/h3>&lt;p>这是一篇很长的文章，所以总结一下我们所学到的东西也许是个好主意。CPython编译器的架构遵循传统设计。它的两个主要部分是前端和后端。前端也被称为解析器。它的工作是将源代码转换为AST。解析器从标记器中获得标记，标记器负责从文本中产生有意义的语言单元流。历史上，解析由几个步骤组成，包括生成解析树和将解析树转换为AST。在CPython 3.9中，新的解析器被引入。它基于一个解析表达式的语法，并直接产生一个AST。后端，自相矛盾地称为编译器，接受AST并产生一个代码对象。它通过首先建立一个符号表，然后创建一个称为控制流图的程序的中间表示法来做到这一点。CFG被组装成一个单一的指令序列，然后由peephole optimizer进行优化。最终，代码对象被创建。&lt;/p>&lt;p>在这一点上，我们有足够的知识来熟悉CPython源代码，并了解它的一些工作。这是我们为&lt;a href="https://tenthousandmeters.com/blog/python-behind-the-scenes-3-stepping-through-the-cpython-source-code/">下一篇&lt;/a>制定的计划.&lt;/p></description></item><item><title>2021</title><link>https://laujay.com/posts/2021/</link><pubDate>Fri, 31 Dec 2021 12:35:49 +0800</pubDate><guid>https://laujay.com/posts/2021/</guid><description>&lt;h2 id="开源">开源&lt;/h2>&lt;p>&lt;a href="https://github.com/elixirschool/elixirschool/pulls?q=is%3Apr+is%3Aclosed++author%3Alau-jay+">elixirschool&lt;/a> 复习的时候做了些简单的翻译和修改&lt;/p>&lt;p>&lt;a href="https://github.com/wechatpy/wechatpy/pulls?q=is%3Apr+is%3Aclosed++author%3Alau-jay+">wechatpy&lt;/a> 工作原因。。&lt;a href="https://github.com/messense">messense&lt;/a> 功德无量啊。节约了多少开发的生命，垃圾微信真的会气死人&lt;/p>&lt;p>&lt;a href="https://github.com/ranaroussi/quantstats/pull/148">quantstats&lt;/a> 工作用到了，客制化的时候发现了些问题做了点贡献&lt;/p>&lt;h2 id="旅游">旅游&lt;/h2>&lt;p>国庆去上海玩了5天，逛吃逛吃。&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/lingang.jpeg" alt="临港">&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/lingang2.jpeg" alt="临港2">&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/nwsd.jpeg" alt="鸟屋">&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/ssxs1.jpeg" alt="上生新所">&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/ssxs2.jpeg" alt="上生新所2">&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/disney1.jpeg" alt="迪士尼1">&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/disney2.jpeg" alt="迪士尼2">&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/disney3.jpeg" alt="迪士尼3">&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/disney4.jpeg" alt="迪士尼4">&lt;/p>&lt;h2 id="技能">技能&lt;/h2>&lt;p>复习了下开车。。太少开了菜的一批。&lt;/p>&lt;p>技术上生产上线了不少Django项目，终于集齐三大框架的龙珠了，体会就是Django大法好！！！&lt;/p>&lt;h2 id="生活">生活&lt;/h2>&lt;p>领养了只狗子， 名字叫麦片。。是个可爱的小姑娘:&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/oatmeal.jpeg" alt="yogurt">&lt;/p>&lt;p>可爱到爆炸，超级乖巧，性格粘人。&lt;/p>&lt;h2 id="最后">最后&lt;/h2>&lt;p>2022年的最大的目标是，不要胖。体脂太高了，没办法兴趣爱好就是泡个老茶，喝个小酒，吃个火锅，养个小狗。除了喝茶和遛狗都是高热量行为。&lt;/p></description></item><item><title>Django Timezone</title><link>https://laujay.com/posts/django-timezone/</link><pubDate>Sat, 28 Aug 2021 19:54:29 +0800</pubDate><guid>https://laujay.com/posts/django-timezone/</guid><description>&lt;h2 id="引言">引言&lt;/h2>&lt;p>线上遇到了个问题， 微信广告的订单回传，时间错了，然后去修这个时间错误。结果发现Django shell里执行datetime.utcnow的结果和now的结果以及time.time的结果居然是一模一样的。然后一路查找，先确认服务器的时间没问题，百思不解，意外在服务器上直接拉起原生的repl发现执行结果又正常了，然后去看代码发现Django的设置里时区被设置为utc了。那么上述所有的问题都得到解答了。所以下面记录下复习Django时区的过程, 如有不对欢迎指正。&lt;/p>&lt;h2 id="utc和gmt8">UTC和GMT+8&lt;/h2>&lt;p>GMT：&lt;strong>G&lt;/strong>reenwich &lt;strong>M&lt;/strong>ean &lt;strong>T&lt;/strong>ime 格林尼治标准时间。这是以英国格林尼治天文台观测结果得出的时间，这是英国格林尼治当地时间，这个地方的当地时间过去被当成世界标准的时间。&lt;/p>&lt;p>UT：&lt;strong>U&lt;/strong>niversal &lt;strong>T&lt;/strong>ime 世界时。根据原子钟计算出来的时间。&lt;/p>&lt;p>UTC：&lt;strong>C&lt;/strong>oordinated &lt;strong>U&lt;/strong>niversal &lt;strong>T&lt;/strong>ime 协调世界时。因为地球自转越来越慢，每年都会比前一年多出零点几秒，每隔几年协调世界时组织都会给世界时+1秒，让基于原子钟的世界时和基于天文学（人类感知）的格林尼治标准时间相差不至于太大。并将得到的时间称为UTC，这是现在使用的世界标准时间。&lt;/p>&lt;p>协调世界时不与任何地区位置相关，也不代表此刻某地的时间，所以在说明某地时间时要加上时区&lt;/p>&lt;p>也就是说GMT并不等于UTC，而是等于UTC+0，只是格林尼治刚好在0时区上。&lt;/p>&lt;p>GMT = UTC+0&lt;/p>&lt;h3 id="naive-datetime-object-vs-aware-datetime-object">&lt;strong>naive datetime object&lt;/strong> vs &lt;strong>aware datetime object&lt;/strong>&lt;/h3>&lt;p>当使用datetime.now()得到一个datetime对象的时候，此时该datetime对象没有任何关于时区的信息，即datetime对象的tzinfo属性为None(tzinfo属性被用于存储datetime object关于时区的信息)，该datetime对象就被称为&lt;strong>naive datetime object&lt;/strong>。&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> datetime&lt;span style="color:#f92672">.&lt;/span>now()&lt;span style="color:#f92672">.&lt;/span>tzinfo&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>既然naive datetime object没有关于时区的信息存储，相对的aware datetime object就是指存储了时区信息的datetime object。在使用now函数的时候，可以指定时区，但该时区参数必须是datetime.tzinfo的子类&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#f92672">from&lt;/span> django.utils.timezone &lt;span style="color:#f92672">import&lt;/span> utc, is_aware&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#f92672">import&lt;/span> datetime&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> datetime&lt;span style="color:#f92672">.&lt;/span>datetime&lt;span style="color:#f92672">.&lt;/span>now()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>datetime&lt;span style="color:#f92672">.&lt;/span>datetime(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">28&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#ae81ff">30&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">922670&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> datetime&lt;span style="color:#f92672">.&lt;/span>datetime&lt;span style="color:#f92672">.&lt;/span>utcnow()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>datetime&lt;span style="color:#f92672">.&lt;/span>datetime(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">28&lt;/span>, &lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#ae81ff">30&lt;/span>, &lt;span style="color:#ae81ff">13&lt;/span>, &lt;span style="color:#ae81ff">591417&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> aware &lt;span style="color:#f92672">=&lt;/span> datetime&lt;span style="color:#f92672">.&lt;/span>datetime&lt;span style="color:#f92672">.&lt;/span>now(utc)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> aware&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>datetime&lt;span style="color:#f92672">.&lt;/span>datetime(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">28&lt;/span>, &lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#ae81ff">30&lt;/span>, &lt;span style="color:#ae81ff">46&lt;/span>, &lt;span style="color:#ae81ff">966581&lt;/span>, tzinfo&lt;span style="color:#f92672">=&amp;lt;&lt;/span>UTC&lt;span style="color:#f92672">&amp;gt;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> is_aware(aware)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">True&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在Django中提供了几个简单的函数如is_aware, is_naive, make_aware和make_naive用于辨别和转换naive datetime object和aware datetime object。&lt;/p></description></item><item><title>Why Three Way Handshake</title><link>https://laujay.com/posts/why-three-way-handshake/</link><pubDate>Sat, 17 Jul 2021 00:49:58 +0800</pubDate><guid>https://laujay.com/posts/why-three-way-handshake/</guid><description>&lt;h1 id="为什么tcp握手要3次">为什么TCP握手要3次&lt;/h1>&lt;p>从两个面试题谈起&lt;/p>&lt;ul>&lt;li>ping 目标主机100ms, 不考虑网络联通问题，理想情况(不考虑丢包）下http多少ms，https多少ms(不考虑非对称加密解密耗时)&lt;/li>&lt;li>TCP三次握手为啥是3次，为什么不是2或者4次，TCP握手到底在干嘛？&lt;/li>&lt;/ul>&lt;p>第一个是朋友谈起的一个面试题，第二个是我问候选人的面试题。&lt;/p>&lt;p>先来说第二个问题，候选人给了我意料中的回复：&lt;/p>&lt;blockquote>&lt;p>打个比方比如打电话：&lt;/p>&lt;ol>&lt;li>你听得到吗？&lt;/li>&lt;li>我能听到，你听得到？&lt;/li>&lt;li>我也能听到&lt;/li>&lt;/ol>&lt;p>所以需要三次&lt;/p>&lt;/blockquote>&lt;p>这回答让人感概颇深, 国内互联网充斥着以讹传讹的博文，却没多少人想着去翻翻RFC。就连教材往往都是语焉不详。&lt;/p>&lt;h3 id="连接是什么">连接是什么&lt;/h3>&lt;p>所以为什么建立连接需要三次？所以TCP握手究竟干了什么？连接是什么？：&lt;/p>&lt;blockquote>&lt;p>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.&lt;/p>&lt;/blockquote>&lt;p>&lt;a href="https://datatracker.ietf.org/doc/html/rfc793">rfc793&lt;/a> 明确定义了连接，这里看最后一句The combination of this information, including sockets, sequence numbers, is called a connection。也就是说连接是一种包括sockets, 序号, 窗口大小这些信息的机制。&lt;/p>&lt;p>连接清楚了，那么接下来探究为什么建立连接需要三次，握手期间是怎么做到初始化信息，注意这里不会讨论其他，主要讨论为啥是三次。&lt;/p>&lt;h3 id="为什么需要三次">为什么需要三次&lt;/h3>&lt;h4 id="旧的重复连接与序号的获取">旧的重复连接与序号的获取&lt;/h4>&lt;blockquote>&lt;p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.&lt;/p>&lt;/blockquote>&lt;p>同样来自&lt;a href="https://datatracker.ietf.org/doc/html/rfc793">rfc793&lt;/a> ，为了阻止历史的重复连接初始化 。这里不妨发挥下脑补能力。现实生活并不美好，真实的网络是不可靠的，大家都知道互联网传输的可靠性在传输层来保证，他是怎么保证的呢。先来看握手图：&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/why-three/handshake-rfc.png" alt="three-handshake">&lt;/p>&lt;p>其实关于第一个面试题中的http的耗时，从这个图里就可以得到结论了。（100/2）* （3 + 2)）=250ms，传输层3次握手加一次应用层协议确立。https以此类推即可。&lt;/p>&lt;p>然后发挥想象：&lt;/p>&lt;p>A发起一个连接，但是过了很久都没收到B的响应（超时了，丢包了等），A不知道是什么原因，于是重发，重发再重发直到放弃。&lt;/p>&lt;p>B收到了A的SEQ是100的请求，只是A不知道还在继续发，B收到了后就知道有关A想搞事儿，如果B不想理就丢弃了，A最终会放弃这个没问题。但是如果B想逗一下A于是就理会了，发了个应答包给A。&lt;/p>&lt;p>当然B也不确定A收到没，而且这里还有可能SEQ是99的包绕路比100还慢, 所以这里得分情况讨论：&lt;/p>&lt;ul>&lt;li>&lt;p>SEQ 100先到了，那这个时候再回应就就是重复了，接受方B不知道哪个更早哪个更迟，所以B的响应会将SEQ+1写到ACK字段里也就是ACK=101给A， 同理B得带上自己的序号SEQ=300 。&lt;/p>&lt;/li>&lt;li>&lt;p>SEQ 99到了。接受方B不知道哪个更早哪个更迟，所以B的响应会将SEQ+1写到ACK字段里也就是ACK=100给A， 同理B得带上自己的序号SEQ=301。&lt;/p>&lt;/li>&lt;/ul>&lt;p>B发送的应答（ACK=101）的可能会发送很多次，但是只要一次到了A，A就认为B同意建立连接搞事儿了，因为对A来说，有去有回。这时候A会给B发送应答应答的应答，B在等这个，应答，也就是A-》B， SEQ=101，ACK=301的应答。&lt;/p>&lt;p>B发送的应答（ACK=100）的可能会发送很多次，但是只要一次到了A，A就发现我要的ack是101， 那么直接发CTL =RST SEQ=100中止了B的SEQ=99的那次连接。&lt;/p>&lt;p>&lt;strong>所以需要第三次来保证旧的连接会被发送方关了，且通信双方都有来有回双方都能互通。&lt;/strong>&lt;/p>&lt;p>到此，我们即握手了三次，又能阻止网络丢包导致的旧握手请求问题，还同步了双方各自发的包的序号，关于序号的获取rfc有如下描述 ：&lt;/p>&lt;blockquote>&lt;p>A three way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN’s. The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN. The three way handshake and the advantages of a clock-driven scheme are discussed in [3].&lt;/p>&lt;/blockquote>&lt;p>那么还剩下最后一个问题，&lt;strong>次数&lt;/strong>。&lt;/p>&lt;h4 id="次数">次数&lt;/h4>&lt;p>上面简单说了3次能保证双方都是有来有回，但是其实只是取了TCP Header优化后的，本质上其实更多次按照这逻辑来做也是行的，比如B对A的响应ACK和SEQ完全可以分两次发，只是头部的设计能让通信更优化一点，B的ACK和SEQ可以一次发送。所以使用最少次数即：&lt;strong>3次&lt;/strong>。&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/why-three/tcp-header-format.png" alt="tcp-header-format">&lt;/p>&lt;p>这里第二个面试题也回答了。&lt;/p></description></item><item><title>Mysql 全表扫描</title><link>https://laujay.com/posts/mysql-full-table-scan/</link><pubDate>Sat, 12 Jun 2021 23:15:49 +0800</pubDate><guid>https://laujay.com/posts/mysql-full-table-scan/</guid><description>&lt;h2 id="背景">背景&lt;/h2>&lt;p>​技术栈是Django ORM + MySQL&lt;/p>&lt;p>​已有的项目，历史原因，Django orm的model里充满了&lt;code>index=True, null=True&lt;/code>, 并且各种操作导致全表扫描特别多。&lt;/p>&lt;h2 id="从innodb的索引说起">从InnoDB的索引说起&lt;/h2>&lt;p>​在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。&lt;/p>&lt;p>​每一个索引在InnoDB里对应一棵B+树，所以索引就是在利用树的结构加速扫描，索引分为主键索引(聚簇索引)和普通索引（二级索引）。行为上的差别是，前者只需要搜索主键B+树，后者需要先搜索该二级索引B+树然后得到ID再搜索主键B+树，也就是普通索引需要回表（查第二次）。更多的细节就不再赘述，那个不是本文的重点。&lt;/p>&lt;h2 id="索引的建立">索引的建立&lt;/h2>&lt;p>基于回表这个操作，对于常用的值，为了减少可以利用覆盖索引的方式，建立联合索引，并且通过规划联合索引的顺序来减少索引数， 不需要回表来提高性能，当然会造成索引树的维护问题，这个需要权衡。&lt;/p>&lt;p>我们的业务表里的很多字段是字符串类型的，并且很多做了联合索引，这里就存在一个问题了。索引的值越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。&lt;/p>&lt;p>更糟糕的是，很多列是&lt;code>null=True&lt;/code> 这就引申出另外一个问题了，索引以及联合索引是否能为null。&lt;/p>&lt;p>关于null是否能作为索引列的值，或者换个说法，索引列是否能为null，先上官方文档：&lt;/p>&lt;blockquote>&lt;p>You can add an index on a column that can have NULL values if you are using the MyISAM, InnoDB, or MEMORY storage engine. Otherwise, you must declare an indexed column NOT NULL, and you cannot insert NULL into the column.&lt;/p>&lt;/blockquote>&lt;p>文档说索引在引擎是InnoDB，MyISAM，MEMORY的情况下是可以为null的，然后还有如&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/is-null-optimization.html">这里所述&lt;/a> 这种索引能够走的前提是你采用is null来判断。最后，如果不采用覆盖索引的方式，&lt;code>select * from xxx&lt;/code> 的话，那么如果数据量少，mysql的优化器可能采用全表扫描。&lt;/p>&lt;p>这是我们代码里的另一类问题，因为各种原因导致的不走索引。&lt;/p>&lt;h3 id="全表扫描的场景">全表扫描的场景&lt;/h3>&lt;ul>&lt;li>&lt;p>在 where 子句中使用 != 操作符，引擎放弃使用索引而进行全表扫描&lt;/p>&lt;/li>&lt;li>&lt;p>在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描&lt;/p>&lt;/li>&lt;li>&lt;p>in 和 not in&lt;/p>&lt;/li>&lt;li>&lt;p>like模糊查询&lt;/p>&lt;/li>&lt;li>&lt;p>在where子句中对字段进行函数操作&lt;/p>&lt;/li>&lt;li>&lt;p>select * from xx&lt;/p>&lt;/li>&lt;li>&lt;p>联合索引中的没利用最左前缀匹配原则&lt;/p>&lt;/li>&lt;/ul>&lt;p>由于情况太多。只列举了我们代码里出现情况。&lt;/p>&lt;h2 id="总结">总结&lt;/h2>&lt;p>​当发现你的代码里出现以上情况之一建议优化，但是不要盲目优化，应该先采profiler工具，以Django为例是增加Django-silk之后， 获取到数据，权衡利弊之后再去做调整。&lt;/p></description></item><item><title>Python的幕后#1: CPython VM 是如何工作的</title><link>https://laujay.com/posts/how-the-cpython-vm-works/</link><pubDate>Fri, 01 Jan 2021 10:20:20 +0800</pubDate><guid>https://laujay.com/posts/how-the-cpython-vm-works/</guid><description>&lt;blockquote>&lt;p>&lt;a href="https://tenthousandmeters.com/blog/python-behind-the-scenes-1-how-the-cpython-vm-works/">原文&lt;/a>&lt;/p>&lt;p>本文已获原文作者&lt;a href="https://tenthousandmeters.com/about/">Victor Skvortsov&lt;/a>授权&lt;/p>&lt;/blockquote>&lt;h2 id="引言">引言&lt;/h2>&lt;p>你是否想过 当你用&lt;code>python&lt;/code>命令执行你的程序的时候, 它做了什么?&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ python script.py&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这篇文章是一系列试图回答这个问题文章的开端。我们将会深入CPython的内部(这是Python最流行的实现)。这样我们将更深入的了解语言本身。这是本系列文章的主要目的。如果你熟悉Python和C，但是并不熟悉CPython源码，那么你可能你会发现本文很有趣。&lt;/p>&lt;h2 id="什么是cpython并且为什么有人想要学习它呢">什么是CPython并且为什么有人想要学习它呢?&lt;/h2>&lt;p>让我们从众所周知的地方开始谈起。 CPython是C语言实现的Python解释器。它是Python的一种实现，其他的实现有PyPy，Jython，IronPython等等。CPython是最原始，维护最久和使用最广的一种实现。&lt;/p>&lt;p>CPython实现了Python，但是什么是Python? 一个简单的回答是：Python是一种编程语言。当更近一步提出相同含义的问题时，答案变得更加具体：什么定义了Python是什么？ Python与C之类的语言不同，它没有正式的规范。 最接近它的是Python语言参考，它开始是以下内容:&lt;/p>&lt;blockquote>&lt;p>当我尝试尽可能精确时，我选择对语法和词法分析以外的所有内容使用英语而不是正式的规范。 这应该使普通读者更容易理解文档，但会存在歧义。 因此，如果您是来自火星并试图仅通过本文档重新实现Python，则您可能不得不猜测，实际上您可能最终会实现完全不同的语言。 另一方面，如果您正在使用Python，并且想知道关于该语言特定区域的确切规则是什么，那么您肯定可以在这里找到它们。&lt;/p>&lt;/blockquote>&lt;p>因此，Python并非仅由其语言参考来定义。说Python是由其参考实现CPython定义的，这也是错误的，因为有些实现细节不是该语言的一部分。依赖引用计数的垃圾收集器就是一个例子。 由于没有单一的事实来源，因此我们可以说Python的一部分是由Python语言参考定义的，另一部分是由其主要实现CPython定义的。&lt;/p>&lt;p>这种说法似乎有些古怪，但我认为弄清这个问题对我们将要研究的主题至关重要。 但是，您可能仍然想知道为什么我们应该研究它。 除了好奇心外，我还发现以下原因:&lt;/p>&lt;ul>&lt;li>&lt;p>纵览全貌可以更深入地了解该语言。 如果您了解Python的某些实现细节，那么掌握Python的某些特性就容易得多。&lt;/p>&lt;/li>&lt;li>&lt;p>语言实现细节在实践中很重要。 当人们想了解语言的适用性及其局限性，估计性能或检测对效率的影响时，对象的存储方式，垃圾收集器的工作方式以及如何协调多个线程是非常重要的主题。&lt;/p>&lt;/li>&lt;li>&lt;p>CPython提供了Python / C API，该API允许使用C扩展Python并将Python嵌入C中。要有效地使用此API，程序员需要对CPython的工作方式有充分的了解。&lt;/p>&lt;/li>&lt;/ul>&lt;h2 id="了解cpython如何工作需要什么">了解CPython如何工作需要什么?&lt;/h2>&lt;p>CPython的设计易于维护。 新手当然可以期望能够阅读源代码并了解其功能。 但是，可能需要一些时间。 通过本系列文章，希望对您有所帮助。&lt;/p>&lt;h2 id="该系列的讲解方式">该系列的讲解方式&lt;/h2>&lt;p>我选择采取自上而下的方式。 在这一部分中，我们将探讨CPython虚拟机（VM）的核心概念。 接下来，我们将了解CPython如何将python源代码编译为VM可以执行的程序。 之后，我们将熟悉CPython源代码，并逐步执行一个程序，在此过程中研究解释器的主要部分。 最终，我们将能够逐一熟悉出语言的不同方面，并查看它们是如何实现的。 这绝不是一个严格的计划，而是我的大概想法。&lt;/p>&lt;p>Note: 在这篇文章中，我指的是CPython 3.9。 随着CPython的发展，某些实现细节肯定会发生变化。 我将尝试跟踪重要的更改并添加更新说明。&lt;/p>&lt;h2 id="概览">概览&lt;/h2>&lt;p>Python程序的执行大致包括三个阶段:&lt;/p>&lt;ol>&lt;li>初始化&lt;/li>&lt;li>编译&lt;/li>&lt;li>解释&lt;/li>&lt;/ol>&lt;p>在初始化阶段，CPython将初始化运行Python所需的数据结构。 它还准备诸如内置类型，配置和加载内置模块，设置导入系统等功能。 这是一个非常重要的阶段，由于其服务的性质，CPython的探索者经常忽略它。&lt;/p>&lt;p>接下来是编译阶段。 从不产生机器代码的意义上讲，CPython是解释器，而不是编译器。 但是，解释器通常在执行之前将源代码转换为某种中间表示。 CPython也是如此。 此翻译阶段执行的操作与典型编译器相同：解析源代码并构建AST（抽象语法树），从AST生成字节码，甚至执行一些字节码优化。&lt;/p>&lt;p>在进行下一阶段之前，我们需要了解什么是字节码。 字节码是一系列指令。 每条指令由两个字节组成：一个字节用于操作码，一个字节用于参数。 考虑一个例子：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(x):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CPython将函数&lt;code>g()&lt;/code>的函数体转换为以下字节序列：[124，0，100，1，23，0，83，0]。 如果我们运行标准库&lt;code>dis&lt;/code>对其进行反汇编，则将获得以下信息：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ python -m dis example1.py&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> LOAD_FAST &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>x&lt;span style="color:#f92672">)&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">(&lt;/span>3&lt;span style="color:#f92672">)&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4&lt;/span> BINARY_ADD&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">6&lt;/span> RETURN_VALUE&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>LOAD_FAST操作码对应于字节124，参数为0。LOAD_CONST操作码对应于字节100，参数为1。BINARY_ADD和RETURN_VALUE指令始终分别编码为（23，0）和（83，0），因为他们不需要参数。&lt;/p>&lt;p>CPython的核心是执行字节码的虚拟机。 通过查看前面的示例，您可能会猜测它是如何工作的。 CPython的VM是基于堆栈的。 这意味着它使用堆栈执行指令来存储和检索数据。 LOAD_FAST指令将局部变量压入堆栈。 LOAD_CONST将一个常数压栈。 BINARY_ADD从堆栈中弹出两个对象，将它们加起来并将结果压回去。 最后，RETURN_VALUE弹出堆栈中的所有内容，并将结果返回给其调用方。&lt;/p>&lt;p>字节码在一个巨大的循环(evaluation loop)中执行，该循环在有指令时运行。 它将在产生值或产生错误时停止。&lt;/p>&lt;p>这样的简短概述会引发很多疑问：&lt;/p>&lt;ul>&lt;li>LOAD_FAST和LOAD_CONST操作码的参数是什么意思？ 他们是指数吗？ 他们索引什么？&lt;/li>&lt;li>VM是否在堆栈上放置值或对对象的引用？&lt;/li>&lt;li>CPython如何知道x是局部变量？&lt;/li>&lt;li>如果参数太大而无法容纳单个字节怎么办？&lt;/li>&lt;li>将两个数字相加的指令是否与连接两个字符串相同？ 如果是，那么VM如何区分这些操作？&lt;/li>&lt;/ul>&lt;p>为了回答这些以及其他有趣的问题，我们需要研究CPython VM的核心概念。&lt;/p>&lt;h2 id="代码对象函数对象帧对象">代码对象，函数对象，帧对象&lt;/h2>&lt;h3 id="代码对象">代码对象&lt;/h3>&lt;p>我们看到了一个简单函数的字节码的样子。 但是典型的Python程序更加复杂。 VM如何执行包含功能定义并进行功能调用的模块？&lt;/p>&lt;p>看下面的代码思考下:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(x):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(f(&lt;span style="color:#ae81ff">1&lt;/span>))&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它的字节码是什么样的？ 为了回答这个问题，让我们分析一下程序的功能。 它定义了函数&lt;code>f&lt;/code>()，以1作为参数调用&lt;code>f()&lt;/code>并输出调用结果。 无论函数&lt;code>f()&lt;/code>做什么，它都不是模块字节码的一部分。 我们可以通过运行反汇编程序来确认这一点。&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>python &lt;span style="color:#f92672">-&lt;/span>m dis example2&lt;span style="color:#f92672">.&lt;/span>py&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">0&lt;/span> (&lt;span style="color:#f92672">&amp;lt;&lt;/span>code object f at &lt;span style="color:#ae81ff">0x10bffd1e0&lt;/span>, file &lt;span style="color:#e6db74">&amp;#34;example.py&amp;#34;&lt;/span>, line &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">1&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;f&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4&lt;/span> MAKE_FUNCTION &lt;span style="color:#ae81ff">0&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">6&lt;/span> STORE_NAME &lt;span style="color:#ae81ff">0&lt;/span> (f)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> LOAD_NAME &lt;span style="color:#ae81ff">1&lt;/span> (print)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">10&lt;/span> LOAD_NAME &lt;span style="color:#ae81ff">0&lt;/span> (f)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">12&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">2&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">14&lt;/span> CALL_FUNCTION &lt;span style="color:#ae81ff">1&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">16&lt;/span> CALL_FUNCTION &lt;span style="color:#ae81ff">1&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">18&lt;/span> POP_TOP&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">20&lt;/span> LOAD_CONST &lt;span style="color:#ae81ff">3&lt;/span> (&lt;span style="color:#66d9ef">None&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">22&lt;/span> RETURN_VALUE&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">...&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在第1行上，我们通过从称为代码对象的对象制作函数并将其绑定到名称来定义函数&lt;code>f()&lt;/code>。 我们看不到函数&lt;code>f()&lt;/code>的字节码返回递增的参数。模块或函数体之类的单个可执行的代码段称为代码块， CPython将有关代码块功能的信息存储在称为代码对象的结构中， 它包含字节码以及该块内使用的变量名称列表之类的内容。 运行模块或调用函数意味着开始执行相应的代码对象。&lt;/p>&lt;h3 id="函数对象">函数对象&lt;/h3>&lt;p>但是，函数不仅是代码对象。 它必须包括其他信息，例如函数名称，文档字符串，默认参数以及在作用域内定义的变量的值。 此信息与代码对象一起存储在功能对象中。 MAKE_FUNCTION指令用于创建它。 在CPython源代码中对函数对象结构的定义前面带有以下注释：&lt;/p>&lt;blockquote>&lt;p>函数对象和代码对象不应相互混淆:&lt;/p>&lt;p>函数对象是通过执行&lt;code>def&lt;/code>语句创建的。他们在其&lt;code>__code__&lt;/code>属性中引用了一个代码对象，该对象是纯粹的语法对象，即仅是某些源代码行的编译版本。每个源代码“片段”有一个代码对象，但是每个代码对象可以被零个或多个函数对象引用，这取决于到目前为止，源代码中的“ def”语句执行了多少次。&lt;/p>&lt;/blockquote>&lt;p>几个函数对象如何引用一个代码对象？ 这是一个例子：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">make_add_x&lt;/span>(x):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">add_x&lt;/span>(y):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> y&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> add_x&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>add_4 &lt;span style="color:#f92672">=&lt;/span> make_add_x(&lt;span style="color:#ae81ff">4&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>add_5 &lt;span style="color:#f92672">=&lt;/span> make_add_x(&lt;span style="color:#ae81ff">5&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>make_add_x()&lt;/code>函数的字节码包含MAKE_FUNCTION指令。函数&lt;code>add_4()&lt;/code>和&lt;code>add_5()&lt;/code>是使用相同的代码对象调用此指令的结果。但是有一个不同的参数– x的值。每个函数都通过&lt;a href="https://tenthousandmeters.com/blog/python-behind-the-scenes-5-how-variables-are-implemented-in-cpython/">cell variables&lt;/a>获得自己的功能，该机制使我们能够创建诸如&lt;code>add_4()&lt;/code>和&lt;code>add_5()&lt;/code>之类的闭包。&lt;/p>&lt;p>在讲述下一个概念之前, 让我们先来查看代码和函数对象的C定义，以更好地了解它们的含义。&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> PyCodeObject {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject_HEAD&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> co_argcount; &lt;span style="color:#75715e">/* #arguments, except *args */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> co_posonlyargcount; &lt;span style="color:#75715e">/* #positional only arguments */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> co_kwonlyargcount; &lt;span style="color:#75715e">/* #keyword only arguments */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> co_nlocals; &lt;span style="color:#75715e">/* #local variables */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> co_stacksize; &lt;span style="color:#75715e">/* #entries needed for evaluation stack */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> co_flags; &lt;span style="color:#75715e">/* CO_..., see below */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> co_firstlineno; &lt;span style="color:#75715e">/* first source line number */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_code; &lt;span style="color:#75715e">/* instruction opcodes */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_consts; &lt;span style="color:#75715e">/* list (constants used) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_names; &lt;span style="color:#75715e">/* list of strings (names used) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_varnames; &lt;span style="color:#75715e">/* tuple of strings (local variable names) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_freevars; &lt;span style="color:#75715e">/* tuple of strings (free variable names) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_cellvars; &lt;span style="color:#75715e">/* tuple of strings (cell variable names) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Py_ssize_t &lt;span style="color:#f92672">*&lt;/span>co_cell2arg; &lt;span style="color:#75715e">/* Maps cell vars which are arguments. */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_filename; &lt;span style="color:#75715e">/* unicode (where it was loaded from) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>co_name; &lt;span style="color:#75715e">/* unicode (name, for reference) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* ... more members ... */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject_HEAD&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_code; &lt;span style="color:#75715e">/* A code object, the __code__ attribute */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_globals; &lt;span style="color:#75715e">/* A dictionary (other mappings won&amp;#39;t do) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_defaults; &lt;span style="color:#75715e">/* NULL or a tuple */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_kwdefaults; &lt;span style="color:#75715e">/* NULL or a dict */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_closure; &lt;span style="color:#75715e">/* NULL or a tuple of cell objects */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_doc; &lt;span style="color:#75715e">/* The __doc__ attribute, can be anything */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_name; &lt;span style="color:#75715e">/* The __name__ attribute, a string object */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_dict; &lt;span style="color:#75715e">/* The __dict__ attribute, a dict or NULL */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_weakreflist; &lt;span style="color:#75715e">/* List of weak references */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_module; &lt;span style="color:#75715e">/* The __module__ attribute, can be anything */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_annotations; &lt;span style="color:#75715e">/* Annotations, a dict or NULL */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>func_qualname; &lt;span style="color:#75715e">/* The qualified name */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vectorcallfunc vectorcall;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} PyFunctionObject;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="帧对象">帧对象&lt;/h3>&lt;p>VM执行代码对象时，必须跟踪变量的值和不断变化值的堆栈。它还需要记住在哪里停止执行当前代码对象以执行另一个代码对象，以及在哪里返回。 CPython将此信息存储在帧对象或简单的帧中。 帧提供了代码对象可以执行需要的状态。 为了让我们对CPython源代码会越来越熟悉，我在这里也保留了帧的定义：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> _frame {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject_VAR_HEAD&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> _frame &lt;span style="color:#f92672">*&lt;/span>f_back; &lt;span style="color:#75715e">/* previous frame, or NULL */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyCodeObject &lt;span style="color:#f92672">*&lt;/span>f_code; &lt;span style="color:#75715e">/* code segment */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>f_builtins; &lt;span style="color:#75715e">/* builtin symbol table (PyDictObject) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>f_globals; &lt;span style="color:#75715e">/* global symbol table (PyDictObject) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>f_locals; &lt;span style="color:#75715e">/* local symbol table (any mapping) */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">**&lt;/span>f_valuestack; &lt;span style="color:#75715e">/* points after the last local */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">**&lt;/span>f_stacktop; &lt;span style="color:#75715e">/* Next free slot in f_valuestack. ... */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>f_trace; &lt;span style="color:#75715e">/* Trace function */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> f_trace_lines; &lt;span style="color:#75715e">/* Emit per-line trace events? */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> f_trace_opcodes; &lt;span style="color:#75715e">/* Emit per-opcode trace events? */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Borrowed reference to a generator, or NULL */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>f_gen;&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> f_lasti; &lt;span style="color:#75715e">/* Last instruction if called */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* ... */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> f_lineno; &lt;span style="color:#75715e">/* Current line number */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> f_iblock; &lt;span style="color:#75715e">/* index in f_blockstack */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> f_executing; &lt;span style="color:#75715e">/* whether the frame is still executing */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyTryBlock f_blockstack[CO_MAXBLOCKS]; &lt;span style="color:#75715e">/* for try and loop blocks */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PyObject &lt;span style="color:#f92672">*&lt;/span>f_localsplus[&lt;span style="color:#ae81ff">1&lt;/span>]; &lt;span style="color:#75715e">/* locals+stack, dynamically sized */&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一个帧在执行模块的代码对象时创建。 每当需要执行另一个代码对象，CPython都会创建一个新帧。 每个帧都有对前一帧的引用。 因此，帧形成帧的栈，也称为调用栈，当前帧位于顶部。 调用函数时，会将新的帧压入栈。 从当前执行的帧返回时，CPython通过记住其最后处理的指令来继续执行前一帧。 从某种意义上来说，CPython VM除了构造和执行帧外什么也不做。 但是，正如我们将很快看到的那样，这个描述，简单来说说，隐藏了一些细节。&lt;/p>&lt;h3 id="线程-解释器-运行时">线程, 解释器, 运行时&lt;/h3>&lt;p>我们已经研究了三个重要概念：&lt;/p>&lt;ul>&lt;li>代码对象&lt;/li>&lt;li>函数对象&lt;/li>&lt;li>帧对象&lt;/li>&lt;/ul>&lt;p>CPython还有三个别的:&lt;/p>&lt;ul>&lt;li>线程状态&lt;/li>&lt;li>解释器状态&lt;/li>&lt;li>运行时状态&lt;/li>&lt;/ul>&lt;h4 id="线程状态">线程状态&lt;/h4>&lt;p>线程状态是一种数据结构，其中包含了线程特有的数据，包括调用堆栈，异常状态和调试设置。&lt;/p>&lt;p>不应将其与操作系统的线程混淆。但是它们有非常紧密的关系，考虑使用标准库 &lt;a href="https://docs.python.org/3/library/threading.html">&lt;code>treading&lt;/code>&lt;/a> 模块在单独的线程里运行函数会发生什么:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> threading &lt;span style="color:#f92672">import&lt;/span> Thread&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>():&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;Perform an I/O-bound task&amp;#34;&amp;#34;&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pass&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>t &lt;span style="color:#f92672">=&lt;/span> Thread(target&lt;span style="color:#f92672">=&lt;/span>f)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>t&lt;span style="color:#f92672">.&lt;/span>start()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>t&lt;span style="color:#f92672">.&lt;/span>join()&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>t.start()&lt;/code> 实际上通过调用操作系统的函数(Unix/Linux系统上是&lt;code>pthread_create()&lt;/code>，Windnows上是&lt;code>_beginthreadex()&lt;/code> )创建了一个新的系统线程. 新创建的线程从&lt;code>_thread&lt;/code>模块中调用负责调用目标的函数.&lt;/p>&lt;p>新创建的线程通过&lt;code>_thread&lt;/code>模块中的函数调用该目标函数。该函数不仅接收目标函数和目标函数的参数，还接收要在新操作系统线程中使用的新线程状态。新操作系统进程将执行循环放入自己的线程状态里， 因此始终可以使用它。&lt;/p>&lt;p>我们可能还记得著名的GIL（全局解释器锁) 它防止多个线程同时进入执行循环。这样做的主要原因是在不引入更多细粒度的锁的情况下保护CPython的状态免受损坏。 &lt;a href="https://docs.python.org/3.9/c-api/index.html">Python/C API 指南&lt;/a> 清楚的解释了GIL:&lt;/p>&lt;blockquote>&lt;p>&lt;em>Python解释器不是完全线程安全的。Python解释器不是完全线程安全的。 为了支持多线程Python程序，有一个全局锁，称为全局解释器锁或GIL，必须由当前线程持有，然后才能安全地访问Python对象。 如果没有锁，即使是最简单的操作也可能在多线程程序中引起问题：例如，当两个线程同时增加同一对象的引用计数时，引用计数最终只能被增加一次，而不是两次。&lt;/em>&lt;/p>&lt;/blockquote>&lt;p>要管理多个线程，需要有一个比线程状态更高级别的数据结构。&lt;/p>&lt;h4 id="解释器和运行时状态">解释器和运行时状态&lt;/h4>&lt;p>实际上，上面说的更高级的数据结构有两个：解释器状态和运行时状态。 两者的差别似乎并不十分明显。&lt;/p>&lt;p>解释器状态是一组线程以及该组特定的数据. 线程共享诸如加载的模块(&lt;code>sys.modules&lt;/code>), 内置模块(&lt;code>builtins.__dict__&lt;/code>)以及导入系统之类的东西 (&lt;code>importlib&lt;/code>)。&lt;/p>&lt;p>运行时状态是全局变量。它存储特定进程的数据。 其中包括CPython的状态（例如，是否已初始化？）和GIL机制。&lt;/p>&lt;p>通常，一个进程的所有线程都属于同一个解释器。 但是，在少数情况下，可能需要创建一个子解释器来隔离一组线程。一个例子是 &lt;a href="https://modwsgi.readthedocs.io/en/develop/user-guides/processes-and-threading.html#python-sub-interpreters">mod_wsgi&lt;/a> ，它使用不同的解释器来运行WSGI应用程序。隔离的最明显效果是每组线程都有自己的所有模块版本，包括&lt;code>__main__&lt;/code>，这是一个全局命名空间。&lt;/p>&lt;p>CPython没有提供类似于&lt;code>threading&lt;/code>模块的简便方法来创建新的解释器。目前仅通过Python/C API提供支持, &lt;a href="https://www.python.org/dev/peps/pep-0554/">但有一天可能会更改&lt;/a> 。&lt;/p>&lt;h3 id="架构摘要">架构摘要&lt;/h3>&lt;p>让我们快速总结一下CPython的体系结构，看看一切如何融合在一起。解释器可以看作是分层结构。 以下总结了这些层是什么:&lt;/p>&lt;ol>&lt;li>运行时: 进程的整体状态；这包括GIL和内存分配机制&lt;/li>&lt;li>解释器: 一组线程和它们共享的一些数据，例如导入的模块。&lt;/li>&lt;li>线程：包含特定数据的操作系统线程； 包括调用堆栈。&lt;/li>&lt;li>帧：调用堆栈的元素； 帧包含一个代码对象，并提供执行它的状态。&lt;/li>&lt;li>执行循环：执行帧对象的地方。&lt;/li>&lt;/ol>&lt;p>这些层由我们已经看到的相应数据结构表示。 在某些情况下，它们并不等价。 例如，使用全局变量来实现内存分配机制。 它不是运行时状态的一部分，但肯定是运行时层的一部分。&lt;/p>&lt;h3 id="结论">结论&lt;/h3>&lt;p>在这一部分中，我们概述了&lt;code>python&lt;/code> 命令为执行Python程序所做的工作。 我们已经看到它在三个阶段起作用:&lt;/p>&lt;ol>&lt;li>初始化CPython&lt;/li>&lt;li>将源代码编译为模块的代码对象； 和&lt;/li>&lt;li>执行代码对象的字节码。&lt;/li>&lt;/ol>&lt;p>解释器中负责字节码执行的部分称为虚拟机。 CPython VM具有几个特别重要的概念：代码对象，帧对象，线程状态，解释器状态和运行时。 这些数据结构构成了CPython体系结构的核心。&lt;/p>&lt;p>我们没有涉及很多东西。 我们避免深入研究源代码。 初始化和编译阶段完全超出了我们的范围。 相反，我们从虚拟机的概述开始。 我认为，通过这种方式，我们可以更好地了解每个阶段的职责。 现在，我们知道了CPython将源代码编译到的代码对象。&lt;/p>&lt;p>&lt;a href="https://laujay.com/posts/how-the-cpython-compiler-works">下一篇&lt;/a>，我们将看到它是如何做到的。&lt;/p></description></item><item><title>golang里被中括号坑的记录</title><link>https://laujay.com/posts/go-regexp/</link><pubDate>Sun, 06 Dec 2020 18:00:59 +0800</pubDate><guid>https://laujay.com/posts/go-regexp/</guid><description>&lt;p>今天众多大佬要用rss订阅本博客。。深感荣幸。。但是出现生成rss文件有错那就尴尬了。&lt;/p>&lt;p>于是到了茶馆打开电脑就开始修。定位了一会就定位到是特殊字符的问题。搜了下查到hugo模版里的replaceRE函数，于是就开始撸正则表达式。结果。。&lt;/p>&lt;h2 id="hugo-replacere-函数好难咱不会用">hugo replaceRE 函数好难咱不会用&lt;/h2>&lt;p>hugo的replaceRE文档有这句话：&lt;/p>&lt;blockquote>&lt;p>Hugo uses Go’s &lt;a href="https://golang.org/pkg/regexp/">Regular Expression package&lt;/a>,which is the same general syntax used by Perl, Python, and other languages but with a few minor differences for those coming from a background in PCRE.&lt;/p>&lt;/blockquote>&lt;p>于是咱就用上了浅薄的正则知识开始撸。很快就撸了一段。。确实也不报错了。于是很开心的提了个pr给用的hugo theme。回头自己看，哎生成的rss里描述的内容咋全是刚换的。知道自己刚写的正则有问题。于是各种尝试。最终的结果都是不起作用。&lt;/p>&lt;h2 id="regexp用的正则语法有问题不是眼神有问题">regexp用的正则语法有问题？不，是眼神有问题&lt;/h2>&lt;p>期间各种尝试。。反正时间很快就没了， 眼瞅着从午饭搞到晚饭了。反正都是不work。&lt;/p>&lt;p>心塞之余还是先去喝茶吧。。果然解决问题如果出现瓶颈就应该放松下。&lt;/p>&lt;p>喝完几泡茶，回到座位，看regexp的文档看到他的语法&lt;a href="https://github.com/google/re2/wiki/Syntax">来源&lt;/a>。&lt;/p>&lt;p>点击去看。。看到&lt;code>[[:cntrl:]] | control (≡ [\x00-\x1F\x7F])&lt;/code>我突然灵机一动把原始的正则给复制过去。居然工作了。比对了下。。才发现人家有俩中括号。。坑死了。&lt;/p></description></item><item><title>2020我做了什么</title><link>https://laujay.com/posts/2020/</link><pubDate>Sat, 05 Dec 2020 21:19:30 +0800</pubDate><guid>https://laujay.com/posts/2020/</guid><description>&lt;blockquote>&lt;p>年结。。233已经不想往上加时间了，于是选择年结。。希望不要烂尾&lt;/p>&lt;/blockquote>&lt;h2 id="开源">开源&lt;/h2>&lt;p>没啥正经的开源项目要忙。。。疫情期间搞了下博客生成器， 换成hugo了。&lt;/p>&lt;p>为此我2020年第一个pr居然是给一个hugo的theme，嗯就是我现在在用的&lt;a href="https://github.com/funkydan2/hugo-kiera">这个&lt;/a>&lt;/p>&lt;p>博客水了几篇文章，技术相关的都是以前的盲区。就是很熟悉但是每次都是糊弄&lt;/p>&lt;p>过去能跑就行，没认真地去研究下， 这是个坏毛病得改。&lt;/p>&lt;h2 id="旅游">旅游&lt;/h2>&lt;p>木有。。。&lt;/p>&lt;h2 id="技能">技能&lt;/h2>&lt;p>由于疫情的问题，导致厨艺大为长进。。已经从熟了进化为能吃，偶尔还能出暴击居然还挺好吃。&lt;/p>&lt;p>最擅长炖肉。。。反正料够都是好吃的。&lt;/p>&lt;p>技术上学了好多有的没的，反正就是随心所欲的学呗。。虽然是低效，但是玩的很开心。。just for fun。当然。。要改。。毕竟生活不止有诗和远方。。还有眼前的苟且。&lt;/p>&lt;h2 id="生活">生活&lt;/h2>&lt;p>最大的变化就是养了只狗子， 名字叫酸奶。。就是这个小子:&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/yogurt.jpeg" alt="yogurt">&lt;/p>&lt;p>这是他小时候，别人帮我喂他的时候拍的，算是他颜值的巅峰吧。&lt;/p>&lt;p>现在已经是一个胖子了&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/yogurt2.jpeg" alt="yogurt2">&lt;/p>&lt;p>然后就是找了私人教开始买课锻炼身体（目的是为了监督我自己）。。疫情期间发生了两次颈椎不适导致的头疼，再不锻炼感觉就要挂了。&lt;/p>&lt;p>附近新开了家茶馆。。非常近，已经是最近固定去处了。&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/guangyunhao.jpeg" alt="广云号">&lt;/p>&lt;h2 id="最后">最后&lt;/h2>&lt;blockquote>&lt;p>初闻不识曲中意， 再闻已是曲中人。&lt;/p>&lt;/blockquote>&lt;p>参加了次发小的婚礼，所见所闻，大多数人都活成了别人想要的样子。&lt;/p>&lt;p>anyway， 开心最重要，不是么。&lt;/p>&lt;p>&lt;img src="https://laujay.com/img/fighting.jpeg" alt="加油">&lt;/p></description></item><item><title>Docker Network External</title><link>https://laujay.com/posts/docker-network-external/</link><pubDate>Thu, 27 Aug 2020 10:41:30 +0800</pubDate><guid>https://laujay.com/posts/docker-network-external/</guid><description>&lt;blockquote>&lt;p>在使用docker的过程中，自建开发环境使用docker-compose是非常正常的需求，正常情况下多个容器都是通过一个docker-compose.yml唤起的，并且可以通过services名直接连接而不需要知道依赖的容器的ip地址。然而，如果遇到容器并非定义在同一个yml中的时候，连接容器就会比较麻烦。我见过直接获取对方容器ip来使用的，但是每次都得获取容器ip地址。&lt;/p>&lt;/blockquote>&lt;p>&lt;a href="https://stackoverflow.com/questions/39067295/docker-compose-external-container">参考自&lt;/a>&lt;/p>&lt;p>在不使用docker-compose的时候可以使用&amp;ndash;link参数如下：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run --rm --name rds -d redis &lt;span style="color:#75715e"># 启动redis&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run --rm --name app --link rds -d task &lt;span style="color:#75715e"># 启动一个应用并连接到rds&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果使用docker-compose就简单了:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">images&lt;/span>: &lt;span style="color:#ae81ff">task&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">depends_on&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">reds&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">res&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">images&lt;/span>: &lt;span style="color:#ae81ff">redis&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在要解决不是一个docker-compose.yml或者是与docker run起来的容器链接的问题。&lt;/p>&lt;p>有几种解决方案，我只推荐使用以下这种方式：&lt;/p>&lt;p>首先是： app.yml&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">images&lt;/span>: &lt;span style="color:#ae81ff">task&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#ae81ff">app&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">networks&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">app_net&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">networks&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app_net&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">external&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着是: rds.yml&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">rds&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">images&lt;/span>: &lt;span style="color:#ae81ff">redis&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#ae81ff">rds&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">networks&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">app_net&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">networks&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app_net&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">external&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用的时候:&lt;/p>&lt;p>deploy.sh :&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>docker network create app_net&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-compose -f ./deploy/rds.yml up -d&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sleep &lt;span style="color:#ae81ff">1&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-compose -f ./deploy/app.yml up -d&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着可以测试下:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker exec -it app ping rds&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>正常情况下会得到ping的结果，是通的。&lt;/p>&lt;p>如果这时候有一个已经存在的容器db，要使用的话可以:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker network connect app_net db&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样三个容器都可以互通了。&lt;/p></description></item><item><title>MQ-RabbitMQ</title><link>https://laujay.com/posts/mq-rabbitmq/</link><pubDate>Wed, 27 May 2020 09:04:57 +0800</pubDate><guid>https://laujay.com/posts/mq-rabbitmq/</guid><description>&lt;p>从一个简单的例子开始。&lt;/p>&lt;p>首先是生产者&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> sys&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> pika&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>credentials &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>PlainCredentials(&lt;span style="color:#e6db74">&amp;#34;guest&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;guest&amp;#34;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>conn_params &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>ConnectionsParameters(&lt;span style="color:#e6db74">&amp;#34;localhost&amp;#34;&lt;/span>, &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> credentials&lt;span style="color:#f92672">=&lt;/span> credentials)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>conn_broker &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>BlockingConnection(conn_params) &lt;span style="color:#75715e"># 到此为止,建立了到代理服务器的链接&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>channel &lt;span style="color:#f92672">=&lt;/span> conn_broker&lt;span style="color:#f92672">.&lt;/span>channel() &lt;span style="color:#75715e"># 获取信道&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>channel&lt;span style="color:#f92672">.&lt;/span>exchange_declare(exchange&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-exchange&amp;#34;&lt;/span>, &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;direct&amp;#34;&lt;/span>, passive&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>, durable&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>, &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> auto_delete&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>) &lt;span style="color:#75715e"># 声明交换器&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>msg &lt;span style="color:#f92672">=&lt;/span> sys&lt;span style="color:#f92672">.&lt;/span>argv[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>msg_props &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>BasicProperties()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>msg_props&lt;span style="color:#f92672">.&lt;/span>content_type&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">“&lt;/span>text&lt;span style="color:#f92672">/&lt;/span>plain&lt;span style="color:#e6db74">&amp;#34;. # 创建纯文本消息&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>channel&lt;span style="color:#f92672">.&lt;/span>basic_publish(body&lt;span style="color:#f92672">=&lt;/span>msg, exchange&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-exchange&amp;#34;&lt;/span>, &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> properties&lt;span style="color:#f92672">=&lt;/span>msg_props,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> routing_key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hola&amp;#34;&lt;/span>) &lt;span style="color:#75715e"># 发布消息&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>conn_broker&lt;span style="color:#f92672">.&lt;/span>close()&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>消费者:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> sys&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> pika&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>credentials &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>PlainCredentials(&lt;span style="color:#e6db74">&amp;#34;guest&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;guest&amp;#34;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>conn_params &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>ConnectionsParameters(&lt;span style="color:#e6db74">&amp;#34;localhost&amp;#34;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> credentials&lt;span style="color:#f92672">=&lt;/span> credentials)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>conn_broker &lt;span style="color:#f92672">=&lt;/span> pika&lt;span style="color:#f92672">.&lt;/span>BlockingConnection(conn_params) &lt;span style="color:#75715e"># 到此为止,建立了到代理服务器的链接&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>channel &lt;span style="color:#f92672">=&lt;/span> conn_broker&lt;span style="color:#f92672">.&lt;/span>channel() &lt;span style="color:#75715e"># 获取信道&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>channel&lt;span style="color:#f92672">.&lt;/span>exchange_declare(exchange&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-exchange&amp;#34;&lt;/span>, &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;direct&amp;#34;&lt;/span>, passive&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>, durable&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>, &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> auto_delete&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>) &lt;span style="color:#75715e"># 声明交换器&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>channel&lt;span style="color:#f92672">.&lt;/span>queue_declare(queue&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-queue&amp;#34;&lt;/span>) &lt;span style="color:#75715e"># 声明队列&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>channel&lt;span style="color:#f92672">.&lt;/span>queue_bind(queue&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-queue&amp;#34;&lt;/span>, exchange&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-exchange&amp;#34;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> routing_key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hola&amp;#34;&lt;/span>) &lt;span style="color:#75715e"># 通过routing_key将队列和交换器绑定起来&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">msg_consumer&lt;/span>(channel, method, header, body):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> channel&lt;span style="color:#f92672">.&lt;/span>basic_ack(delivery_tag&lt;span style="color:#f92672">=&lt;/span>method&lt;span style="color:#f92672">.&lt;/span>delivery_tag)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> body&lt;span style="color:#f92672">.&lt;/span>decode(&lt;span style="color:#e6db74">&amp;#34;utf8&amp;#34;&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;quit&amp;#34;&lt;/span>: &lt;span style="color:#75715e"># 例子来源于rabbitmq实战,但是body在 python3中是byte类型&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> channel&lt;span style="color:#f92672">.&lt;/span>basic_cancel(consumer_tag&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello-consumer&amp;#34;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> channel&lt;span style="color:#f92672">.&lt;/span>stop_consuming()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(body&lt;span style="color:#f92672">.&lt;/span>decode(&lt;span style="color:#e6db74">&amp;#34;utf8&amp;#34;&lt;/span>))&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>channel&lt;span style="color:#f92672">.&lt;/span>basic_consume(queue&lt;span style="color:#f92672">=&lt;/span>queue_name, &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> on_message_callback&lt;span style="color:#f92672">=&lt;/span> msg_consumer, auto_ack&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>channel&lt;span style="color:#f92672">.&lt;/span>start_consuming()&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="生产者和消费者">生产者和消费者&lt;/h2>&lt;p>生产者创建消息=》发布到代理服务器(RabbitMQ)&lt;/p>&lt;h3 id="消息">消息&lt;/h3>&lt;p>消息分为: payload和label&lt;/p>&lt;p>payload是你要传输的内容,label描述了有效载荷.&lt;/p>&lt;p>AMQP用标签表述消息, rabbitmq根据标签把消息发送给感兴趣的接受放. 其方式是fire-and-forget&lt;/p>&lt;p>接受者得到payload, 标签在过程中不会发送&lt;/p>&lt;h3 id="持久化消息">持久化消息&lt;/h3>&lt;p>delivery mode 设置为2, 但是必须是持久化的交换器和持久化的队列, 三者加在一起才能真正具有持久化.&lt;/p>&lt;h3 id="信道channel">信道(channel)&lt;/h3>&lt;p>信道事建立在“真实” TCP链接内的虚拟链接, 信道复用TCP链接,可以有无数个信道,但是会共用一个TCP链接.&lt;/p>&lt;h2 id="amqp三要素">AMQP三要素&lt;/h2>&lt;h3 id="交换器exchange">交换器(exchange)&lt;/h3>&lt;p>生产者把消息发布到交换器上&lt;/p>&lt;p>交换器根据routing-key来决定消息投递到哪个队列&lt;/p>&lt;p>队列通过routing-key绑定到交换器.&lt;/p>&lt;p>交换器类型: topic, fanout, direct, headers&lt;/p>&lt;p>direct: 如果路由键匹配,就投递到对应的队列&lt;/p>&lt;p>fanout: 广播到所有绑定到该交换器的队列上&lt;/p>&lt;p>topic: 多个来源的消息到同一个队列上&lt;/p>&lt;h3 id="持久化">持久化&lt;/h3>&lt;p>durable设置为True&lt;/p>&lt;h3 id="队列queue">队列(queue)&lt;/h3>&lt;p>消息到达队列,并被消费者接受&lt;/p>&lt;h3 id="创建队列">创建队列&lt;/h3>&lt;p>queue.declare, 如果消费者在一条信道上订阅了某个队列,无法再声明队列了, 必须先取消订阅, 将 信道设置为“传输模式”.&lt;/p>&lt;p>queue.declare有两个参数:&lt;/p>&lt;ul>&lt;li>&lt;p>exclusive, 为true, 队列私有, 只能创建的使用,一个队列一个消费者&lt;/p>&lt;/li>&lt;li>&lt;p>auto-delete , 最后一个消费者取消订阅后, 队列自动移除.&lt;/p>&lt;/li>&lt;/ul>&lt;p>交换器是topic情况下:queue.bind_queue通过指定队列名, 交换器名, 和绑定键名, 将队列绑定到交换器.&lt;/p>&lt;h3 id="持久化-1">持久化&lt;/h3>&lt;p>durable设置为True&lt;/p>&lt;h3 id="绑定bind_key">绑定(bind_key)&lt;/h3>&lt;p>绑定key决定了交换器将符合绑定key规则的消息都发送到这个队列里.&lt;/p>&lt;h2 id="vhost虚拟主机">vhost虚拟主机&lt;/h2>&lt;p>虚拟主机实现了自身的交换器,队列,和绑定, 并且带有权限控制&lt;/p>&lt;p>vhost只能通过命令行来创建删除&lt;/p>&lt;h3 id="创建">创建&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># rabbitmqctl add_vhost[vhost_name]&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除">删除&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># rabbitmqctl delete_vhost[vhost_name]&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="显示">显示&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># rabbitmqctl list_vhosts&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="多个消费者订阅到同一队列如何分发消息">多个消费者订阅到同一队列,如何分发消息&lt;/h2>&lt;p>rabbitmq拥有多个消费者的时候, 队列收到的消息将以(round-robin)的方式发送给消费者, 每个消息只会发送给一个消费者.&lt;/p>&lt;h2 id="ack机制">ACK机制&lt;/h2>&lt;p>消费者确认消息会basic.ack显式发送确认.或者auto-ack为true. 如果没有ack,链接断开,那么该消息会被发给下一个 消费者, 确保消息被正确处理.&lt;/p>&lt;p>如果没有返回ack,那么rabbitmq不会发送下一条消息给消费者.&lt;/p>&lt;h2 id="reject机制">Reject机制&lt;/h2>&lt;p>如果消费者容易出问题,但是消息又不想删除, 两种做法,第一断开链接,第二 basic.reject(版本大于2.0).&lt;/p>&lt;p>如果reject设置了requeue参数为true, 该消息会被发给下一个消费者.&lt;/p></description></item><item><title>The Python Packaging</title><link>https://laujay.com/posts/the-python-packaging/</link><pubDate>Thu, 14 May 2020 08:39:47 +0800</pubDate><guid>https://laujay.com/posts/the-python-packaging/</guid><description>&lt;h2 id="名字">名字&lt;/h2>&lt;p>Python的模块或者包名应该遵循下面几条:&lt;/p>&lt;ul>&lt;li>总是小写&lt;/li>&lt;li>pypi上唯一&lt;/li>&lt;li>不要用中划线分隔，下划线或者干脆不要分隔单词&lt;/li>&lt;/ul>&lt;h2 id="最小结构">最小结构&lt;/h2>&lt;pre tabindex="0">&lt;code>jay_hello/ jay_hello/ __init__.py setup.py&lt;/code>&lt;/pre>&lt;p>假设，&lt;code>__init__.py&lt;/code>文件里就一个hello_world&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">hello_world&lt;/span>():&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;hello world!&amp;#34;&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>setup.py文件里应该是以下内容:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> setuptools &lt;span style="color:#f92672">import&lt;/span> setup&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>setup(name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;jay_hello&amp;#34;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;0.0.1&amp;#34;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;just say hello&amp;#34;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;https://github.com/lau-jay/jay_hello&amp;#34;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> author&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Lau Jay&amp;#34;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> author_email&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;example@gamil.com&amp;#34;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> license&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;MIT&amp;#39;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> packages&lt;span style="color:#f92672">=&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;jay_hello&amp;#34;&lt;/span>],&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zip_safe&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在可以通过下面这种方式安装&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>pip install . &lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>本地开发时建议使用下面这种，原因是其使用了软链接，你对代码文件的任何更改不再需要任何操作被使用&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>pip install -e .&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>packaging.python.org上的原文是: &lt;code>in such a way that the project appears to be installed, but yet is still editable from the src tree&lt;/code>&lt;/p>&lt;p>那么现在就可以在repl里导入使用了&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>python setup.py develop &lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个是&lt;code>pip install -e .&lt;/code>底层实际执行的方法，会在&lt;code>site-packages&lt;/code>里创建&lt;code>.egg-link&lt;/code> 文件去链接源码目录&lt;/p>&lt;h2 id="pypi上发布">PyPI上发布&lt;/h2>&lt;h3 id="注册账户">注册账户&lt;/h3>&lt;p>略&lt;/p>&lt;h3 id="注册名字上传元数据以及创建包页面创建分发包并上传">注册名字，上传元数据以及创建包页面，创建分发包并上传&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>python setup.py register sdist upload&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="安装包">安装包&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>pip install jay_hello&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="setuppy">setup.py&lt;/h2>&lt;p>setup参数解析&lt;/p>&lt;h3 id="依赖">依赖&lt;/h3>&lt;p>&lt;code>install_requires&lt;/code>类型是字符串或者字符串列表，&lt;/p>&lt;p>ps: 19.0版本开始pip移除了对 &lt;code>dependency_links&lt;/code> 的支持&lt;/p>&lt;h3 id="提供命令行">提供命令行&lt;/h3>&lt;p>&lt;code>entry_points&lt;/code>：这个参数允许Python函数直接注册为命令行工具，这个机制非常可以方便地提供程序的命令行工具&lt;/p>&lt;pre tabindex="0">&lt;code class="language-ptyhon" data-lang="ptyhon">setup( ... entry_points = { &amp;#34;console_scripts&amp;#34;: [&amp;#34;jayhello= jay_hello:hello_world&amp;#34;], })&lt;/code>&lt;/pre>&lt;p>&lt;code>scripts&lt;/code> : 安装包的时候，setuptools会拷贝脚本到PATH，可以像Linux命令那样使用，这个字段指定的脚本不需要是Python脚本，任何可执行的都行, 假设增加了一个bin目录，并增加一个shell脚本&lt;/p>&lt;pre tabindex="0">&lt;code>setup( ... scripts=[&amp;#34;/bin/run.sh&amp;#34;])&lt;/code>&lt;/pre>&lt;h3 id="添加非代码文件">添加非代码文件&lt;/h3>&lt;p>如果是图像，数据表，文档等。为了让setuptools正确处理他们&lt;/p>&lt;p>需要添加个MANIFEST.in文件，例如：&lt;/p>&lt;pre tabindex="0">&lt;code>include README.mdinclude docs/*.md&lt;/code>&lt;/pre>&lt;p>为了启用这些，需要如下设置参数:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>setup(&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> include_package_data&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>更多参数请参见&lt;a href="setuptools.readthedocs.io/en/latest/setuptools.html">stuptools文档&lt;/a>&lt;/p></description></item><item><title>The Pytest Discovery</title><link>https://laujay.com/posts/the-pytest-path/</link><pubDate>Fri, 08 May 2020 07:38:45 +0800</pubDate><guid>https://laujay.com/posts/the-pytest-path/</guid><description>&lt;blockquote>&lt;p>对于pytest，我一直是使用，看文档也是只看fixture那部分的。昨天跟公司的vp争论一个问题，vp觉得tests目录下不该有 &lt;code>__init__.py&lt;/code>文件，这样子对于unite test来说语义是不对的。要使用&lt;code>setup.py develop&lt;/code>将包装载后测试，这样就不会出现我引入&lt;code>__init__.py&lt;/code>的初衷，为了找到找不到要测试的包。&lt;/p>&lt;/blockquote>&lt;p>首先，我没有认真研究为啥找不到包，但是加了&lt;code>__init__.py&lt;/code>在tests目录就能够正常pytest命令跑完测试。也就是说我是不知道原因的情况下，误打误撞利用的pytest的机制。&lt;/p>&lt;p>为了搞清这个问题我认真阅读了&lt;a href="https://docs.pytest.org/en/latest/goodpractices.html#tests-outside-application-code">该章&lt;/a> 发现了如下的文字:&lt;/p>&lt;blockquote>&lt;pre tabindex="0">&lt;code>setup.pymypkg/ ...tests/ __init__.py foo/ __init__.py test_view.py bar/ __init__.py test_view.py&lt;/code>&lt;/pre>&lt;p>But now this introduces a subtle problem: in order to load the test modules from the &lt;code>tests&lt;/code> directory, pytest prepends the root of the repository to &lt;code>sys.path&lt;/code>, which adds the side-effect that now &lt;code>mypkg&lt;/code> is also importable.This is problematic if you are using a tool like &lt;a href="https://docs.pytest.org/en/latest/goodpractices.html#tox">tox&lt;/a> to test your package in a virtual environment, because you want to test the &lt;em>installed&lt;/em> version of your package, not the local code from the repository.&lt;/p>&lt;/blockquote>&lt;p>解释下，意思是，如果你通过添加&lt;code>__init__.py&lt;/code>改变测试目录，使其变为一个测试模块，那么pytest会将根目录添加到sys.path中，使得同级的python包mypkg也可以导入了。但是对于使用tox来多环境测试来说，这是有问题的。&lt;/p>&lt;p>所以mypkg也能导入这就是我能顺利运行pytest的原因，但是这种情况下，对tox使用不利，虽然公司的代码限定了python版本不需要使用tox。&lt;/p>&lt;p>&lt;a href="https://laike9m.com/">laike9m&lt;/a> 说conftest.py文件的机制能达到相同的效果，而且不需要&lt;code>__init__.py&lt;/code> 。&lt;/p>&lt;p>找到文档描述在&lt;a href="https://docs.pytest.org/en/latest/pythonpath.html?highlight=conftest#pytest-import-mechanisms-and-sys-path-pythonpath">这&lt;/a>&lt;/p>&lt;p>但是比较奇怪，需要人为加&lt;code>conftest.py&lt;/code> 文件在待测试包的同级别目录&lt;/p>&lt;pre tabindex="0">&lt;code>setup.pymypkg/ ...conftest.pytests/ foo/ __init__.py test_view1.py bar/ __init__.py test_view2.py&lt;/code>&lt;/pre>&lt;p>这样子也行。。&lt;/p>&lt;p>无论哪种做法都是利用了pytest，而不是将包安装进site-packages&lt;/p></description></item><item><title>Pyenv Guide on OSX</title><link>https://laujay.com/posts/pyenv-guide-on-osx/</link><pubDate>Wed, 01 Apr 2020 11:29:34 +0800</pubDate><guid>https://laujay.com/posts/pyenv-guide-on-osx/</guid><description>&lt;blockquote>&lt;p>好久不用。。发现都忘记怎么用了。赶紧写个笔记&lt;/p>&lt;/blockquote>&lt;h1 id="mac-osx-python开发环境配置之-pyenv">Mac OSX Python开发环境配置之 pyenv&lt;/h1>&lt;p>首先 打开terminal.app 或者 iterm2&lt;/p>&lt;p>&lt;code>$ brew install pyenv&lt;/code>&lt;/p>&lt;p>然后&lt;/p>&lt;p>&lt;code>$ pyenv versions&lt;/code>&lt;/p>&lt;p>检查pyenv安装完成与否&lt;/p>&lt;p>接着安装pyenv-virtualenv 插件&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ brew install pyenv-virtualenv&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加这几句到 .bashrc文件里&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;~/.pyenv/bin:&lt;/span>$PATH&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eval &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>pyenv init -&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eval &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>pyenv virtualenv-init -&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后执行&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ source ~./bashrc &lt;span style="color:#75715e"># 如果是zsh就是~./zshrc 让当前环境变量生效&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用法：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ pyenv install 2.7.16&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pyenv versions&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> system&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2.7.16&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2.7.16/envs/fire_env&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3.6.8&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3.7.2&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>* 3.7.4 &lt;span style="color:#75715e"># 这个表示当前环境的Python解释器版本&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pyenv virtualenv 2.7.16 virtual_27&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个时候你使用pyenv versions 你就会看到virtual_27&lt;/p>&lt;p>然后找个目录创建个目录叫&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ mkdir virtual_env&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd virtual_env&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pyenv local virtual_27&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>virtual_27&lt;span style="color:#f92672">)&lt;/span>$ pyenv versions&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>system&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2.7.16&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2.7.16/envs/virtual_27&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3.6.8&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3.7.2&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3.7.4&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3.7.4/envs/374camp&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 374camp&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>* virtual_27 &lt;span style="color:#f92672">(&lt;/span>set by /Users/jay/Workspace/virtual_env/virtual_27/.python-version&lt;span style="color:#f92672">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后你就会发现每次，进入virtual_env 就会自动激活对应的虚拟环境了,美元符号前面的会显示你当前的虚拟环境。&lt;/p>&lt;p>notes：&lt;/p>&lt;p>如果你遇到了这样的报告：&lt;/p>&lt;p>​ &lt;code> xxx export PYENV_VIRTUALENV_DISABLE_PROMPT=1 xxxx&lt;/code>&lt;/p>&lt;p>​ 那么复制&lt;code>export PYENV_VIRTUALENV_DISABLE_PROMPT=1&lt;/code> 到命令行下面执行就好了。&lt;/p>&lt;p>使用这两个工具的好处是，可以让你的电脑上存在N个不同版本的Python，并且可以进入目录切换。&lt;/p></description></item><item><title>TCP/IP网络编程</title><link>https://laujay.com/posts/tcp-ip/</link><pubDate>Sat, 28 Mar 2020 21:26:30 +0800</pubDate><guid>https://laujay.com/posts/tcp-ip/</guid><description>&lt;blockquote>&lt;p>本文图片来源于geektime网络编程实战，版权归其所有&lt;/p>&lt;/blockquote>&lt;p>网络编程的大部分内容就是设计并实现应用层协议，应用层以下的都由套接字封装了。下面逐步讲解套接字。&lt;/p>&lt;h2 id="服务器端建立连接">服务器端建立连接&lt;/h2>&lt;p>调用socket函数，返回fd（买了个电话机）&lt;/p>&lt;p>调用bind函数，分配地址信息（去电信局申请下来了电话号码）&lt;/p>&lt;p>调用listen函数，转化为🉑️接收连接状态（安装好电话线了）&lt;/p>&lt;p>调用accept函数，受理连接请求（接听电话）&lt;/p>&lt;p>总结：&lt;/p>&lt;p>第一步调用socket创建套接字。&lt;/p>&lt;p>第二步调用bind函数分配IP地址和端口号。&lt;/p>&lt;p>第三步调用listen函数转为可接收请求状态。&lt;/p>&lt;p>第四步调用accpet函数受理连接请求。&lt;/p>&lt;h3 id="客户端建立连接">客户端建立连接&lt;/h3>&lt;p>调用socket函数，返回fd（买了个电话机）&lt;/p>&lt;p>调用connect，拨通电话，等待服务器accept&lt;/p>&lt;h4 id="完整过程如下图">完整过程如下图&lt;/h4>&lt;p>&lt;img src="https://laujay.com/img/tcp-ip.png" alt="tcp-ip">&lt;/p>&lt;h3 id="套接字">套接字&lt;/h3>&lt;p>首先：协议是为了完成数据交换而定好的约定。&lt;/p>&lt;p>&lt;code>int socket(int domain, int type, int protocol)&lt;/code>&lt;/p>&lt;p>这是socket函数的声明。那么这里可以看到3个参数，第三个就是协议，这就是为什么开头要先确定协议是什么。&lt;/p>&lt;p>协议其实一般叫协议族。这个名字不是乱起的，族最字面的解释就是一大家子。比如TCP/IP名字就叫TCP/IP协议族，从头文件&lt;code>sys/socket.h&lt;/code>中可以找到以下各种协议族。&lt;/p>&lt;table>&lt;thead>&lt;tr>&lt;th>名称&lt;/th>&lt;th>协议族&lt;/th>&lt;/tr>&lt;/thead>&lt;tbody>&lt;tr>&lt;td>PF_INET&lt;/td>&lt;td>IPv4互联网协议族&lt;/td>&lt;/tr>&lt;tr>&lt;td>PF_INET6&lt;/td>&lt;td>IPv6互联网协议族&lt;/td>&lt;/tr>&lt;tr>&lt;td>PF_LOCAL&lt;/td>&lt;td>本地通信的UNIX协议族&lt;/td>&lt;/tr>&lt;tr>&lt;td>&amp;hellip;&lt;/td>&lt;td>&amp;hellip;&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table>&lt;p>而第一个参数 &lt;code>domain&lt;/code>，其实就是协议族，第一个参数协议族，第三个参数是具体协议族里的某个协议。第一个参数决定了第三个参数的范围。&lt;/p>&lt;p>第二个参数 &lt;code>type&lt;/code>, 查看man手册可以看到&lt;code>SOCK_STREAM&lt;/code>, &lt;code>SOCK_DGRAM&lt;/code>, &lt;code>SOCK_RAW&lt;/code>这三种传输方式，事实上，协议族定了并不能决定传输方式。&lt;/p>&lt;p>首先无视掉&lt;code>SOCK_RAW&lt;/code>因为man下查看文档你会发现这句话 &lt;code>The type SOCK_RAW, which is available only to the super-user.&lt;/code>。&lt;/p>&lt;p>&lt;code>SOCK_STREAM&lt;/code> 这种类型的将创建面向连接的套接字。&lt;code>SOCK_STREAM类型提供基于序列的，可靠的，双向连接的字节流&lt;/code> , 因为套接字内部存在buffer，简单来说就是字节数组，只要不超过buffer的大小，所以read和write的调用次数不限，所以不存在数据边界。&lt;/p>&lt;p>&lt;code>SOCK_DGRAM&lt;/code> 这种类型将创建面向消息的套接字。&lt;code>SOCK_DGRAM类型提供不可靠、不按序传递、以数据的高速传输为目的的套接字&lt;/code>强调快速而非传输顺序。传输的数据可能丢失也可能损毁。传输的数据有边界（发几次就得收几次，而不能攒着一次收了）。限制传输的数据的大小。&lt;/p>&lt;p>第三个参数&lt;code>protocol&lt;/code>，如果一个族内一种数据传输方式的协议只有一种，严格意义上来说，前两个参数就足以确定某个协议了，但是有些族中存在一些一些有多种数据传输方式。&lt;/p>&lt;h3 id="分配ip地址和端口">分配IP地址和端口&lt;/h3>&lt;p>当获取到socket的文件描述符之后，需要分配IP地址和端口号。&lt;/p>&lt;h4 id="ip地址">IP地址&lt;/h4>&lt;p>IP地址分为两类，IPv4， IPv6。二者区别主要是字节数，目前通用的IPv4，IPv6是为了解决IP地址耗尽提出的标准。&lt;/p>&lt;p>IPv4地址是有分类的，IP地址，逻辑上分为网络号、子网号、主机号。&lt;/p>&lt;p>IP地址的分类以网络号作为区分，网络号占1字节的为A类：0～127，B类占据2字节： 128～191，c类占据3字节192～223，D类4字节。&lt;/p>&lt;p>网络的实际构成，在NAT技术下，可以理解为公网IP是一个个路由器或者交换机，实际上是先向路由器发送数据，再由路由器NAT 映射进子网内，再在子网内通过子网IP地址去(arp)找到MAC地址寻址发送过去。MAC地址只能在子网内起作用（虽然说要求全球唯一）&lt;/p>&lt;h4 id="端口号">端口号&lt;/h4>&lt;p>主机是能运行多个程序的，且大多数情况下共用同一个IP地址，为了区分哪些数据是哪些程序的。操作系统通过端口号，去分配相应的数据给对应端口的套接字（也就是相应的程序）。&lt;/p>&lt;p>端口号由16位构成，所以范围是0～65535。但是0～1023的知名端口是分配给特定应用程序的，所以一般应用分配的端口为1024～65535.&lt;/p>&lt;p>此外，TCP和UDP是不同的模块分配的，所以相同端口的UDP和TCP套接字是允许的。&lt;/p>&lt;p>IPv4地址的是以结构体的方式表示的。其结构如下:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> sockaddr_in&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">sa_family_t&lt;/span> sin_family; &lt;span style="color:#75715e">//地址族&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> uint16_y sin_port; &lt;span style="color:#75715e">//16位端口， htons()网络字节序保存&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> in_addr sin_addr; &lt;span style="color:#75715e">//32位IP地址, htons()&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> sin_zero[&lt;span style="color:#ae81ff">8&lt;/span>]; &lt;span style="color:#75715e">//不使用,为确保与sockaddr结构保持一致的填充&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> in_addr&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">in_addr_t&lt;/span> s_addr; &lt;span style="color:#75715e">//32位IPv4， 网络字节序保存,htons()&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了填充地址结构体外，传输的数据等都无需要转换字节序，因为会自动做。IPv4与IPv6及通用地址结构对比如下图:&lt;img src="https://laujay.com/img/addr-struct.png" alt="addr-struct">&lt;/p>&lt;p>IP地址是点分十进制的，为了转换成32位的整数型数据。在&lt;code>&amp;lt;arpa/inet.h&amp;gt;&lt;/code>里提供了一个函数&lt;code>in_addr_t inet_addr(const char* string);&lt;/code> 该函数会获取一个点分十进制IP地址的字符串，返回32位整数型数据并返回。&lt;/p>&lt;p>INADDR_ANY常量可以作为初始化服务器IP地址时的IP使用，因为会自动获取服务器端的计算机IP地址。&lt;/p>&lt;p>地址结构体初始化好后，可以给套接字分配地址信息。将初始化好的地址信息通过bind函数分配。&lt;/p>&lt;p>&lt;code>int bind(int socket, const struct sockaddr *address, sockelen_t address_len);&lt;/code>&lt;/p>&lt;p>sockfd经过bind这步完成后，物料已经准备好了，可以开始等待请求了。进入等待请求需要调用&lt;code>int listen(int socket, int backlog)&lt;/code> backlog是最多允许多少个连接请求进度队列。&lt;/p>&lt;p>到这里服务器的所有工作已经就绪，当有请求来的时候，其实就可以处理了。但是，由于之前那个套接字是为了接收连接请求而创建的。真正连接着客户并交换数据的是另一个套接字。可以调用&lt;code> int accept(int socket, struct sockaddr *restrict address, socklen_t *restrict address_len)&lt;/code> 来创建并连接到发起请求的客户端。&lt;/p>&lt;p>accept函数受理连接请求（backlog, 未完成连接队列的大小）中待处理的客户端连接请求。&lt;/p>&lt;p>TCP连接的server端是在accept系统调用中完成从LISTEN到SYN-RCVD（收到SYN），再到ESTABLISHED（收到ACK）的变迁过程。&lt;/p>&lt;h4 id="优雅的关闭套接字">优雅的关闭套接字&lt;/h4>&lt;p>tcp的半关闭：&lt;/p>&lt;p>Linux的close函数意味着完全断开连接。这意味着不仅不能传输也不能接收数据。&lt;/p>&lt;p>这会造成数据的损毁。那么半关闭的方法就产生了。半关闭就是将全双工的socket变为可以接收数据但无法传输，或者可以传输但无法接收。只关闭流的一半。&lt;/p>&lt;p>socket是全双工的，本质上来说 有两个流，客户端的输出流对着服务器端的输入流，客户端的输入流对着服务器端的输出流。半关闭就是断掉其中一个。&lt;/p>&lt;p>&lt;code>int shutdown(int socket, int how)&lt;/code> 两个参数分别是需要断开的套接字文件描述符和传递断开方式信息。&lt;/p>&lt;p>第二个参数有三个选项 ：&lt;/p>&lt;ul>&lt;li>SHUT_RD: 断开输入流&lt;/li>&lt;li>SHUT_WR: 断开输出流&lt;/li>&lt;li>SHUT_RDWR: 同时断开I/O流，相当于调用了两次hsutdown，第一次以SHUT_RD为参数，第二次以SHUT_WR为参数。&lt;/li>&lt;/ul>&lt;p>既要发送传输结束的信号，又要接收数据时，服务器端可以关闭输出流，通知客户端(客户端接收数据)。&lt;/p>&lt;h4 id="套接字的多种可选项">套接字的多种可选项&lt;/h4>&lt;p>套接字分层 &lt;code>IPPROTO_IP&lt;/code>层可选项是IP协议相关的， &lt;code>IPPROTO_TCP&lt;/code>是TCP协议相关的，&lt;code>SOL_SOCKET&lt;/code>是套接字相关的可选项。&lt;/p>&lt;p>&lt;code>int getsocketopt(int socket, int level, int option_name, const void *option_value, socklen_t options_len&lt;/code>) 这个函数用户读取套接字的可选项。&lt;/p>&lt;p>&lt;code> int setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len);&lt;/code> 这个函数用于更改可选项。&lt;/p>&lt;p>套接字类型只能在创建的时候决定，以后不能再改，也就是说tcp套接没法改成udp套接字。&lt;/p>&lt;h4 id="time-wait">TIME-WAIT&lt;/h4>&lt;p>TIME-WAIt是指主动发起方，四次握手后其实并没有真正关闭，而是会有一小段的存活期，在此期间占据的端口是无法绑定的，因为还在使用中呢。四次挥手的时候，假设是服务器端主动发起Fin，如果服务器端不存在TIME-WAIT，当服务器主动发起Fin的时候，最后一次的ACK是第一个发FIN的发出去。如果没有TIME-WAIT那么，如果这个ACK回给客户端的时候失败了，客户端会重发自己的Fin，然而这个Fin永远得不到ACK，于是会一直重传，如果服务器处于TIME-WAIT，则有机会向客户端重传最后的ACK，客户端有机会正常终止。&lt;/p>&lt;p>第二个是确保迷走报文的自动消失。客户端其实也有TIME-WAIT，只是客户端的端口是随机分配的，所以比较少绑定端口错误。&lt;/p>&lt;p>如果需要快速重启，避过TIME-WAIT，在套接字可选项中更改&lt;code>SO_REUSEADDR&lt;/code>的状态，将其改为1（真）就表示可以分配TIME-WAIT状态下的端口号。如果要解决TIMT-WAIT占用内存和占用端口的问题。需要设置 &lt;code>net.ipv4.tcp_timestamps=1(默认)&lt;/code> 以及 &lt;code>net.ipv4.tcp_tw_reuse&lt;/code>。&lt;/p>&lt;h4 id="nagle算法">Nagle算法&lt;/h4>&lt;p>TCP默认使用Nagle算法，最大限度的进行缓冲，直到之前的收到了ACK，于是将缓冲区内的全部填入一个数据报内，减少网络包数目，降低负载。&lt;/p>&lt;p>当流量未受影响时，Nagle算法用了比不用慢，典型的是传输大文件数据时。&lt;/p>&lt;p>将&lt;code>TCP_NODELAY&lt;/code> 改为1（真）就会禁用Nagle算法。&lt;/p>&lt;h1 id="知识补给">知识补给&lt;/h1>&lt;p>ssize_t 表示 signed int类型，size_t表示unsigned in类型，这么做是为了可移植性。因为操作系统的位数在增加，到时候只需要改头文件里的声明就好了。&lt;/p>&lt;p>_t结尾表示操作系统定义的数据类型。&lt;/p>&lt;p>uint16_t表示16位无符号整数&lt;/p>&lt;p>sockaddr_in是IPv4的地址信息结构体，但是sockaddr结构体不是只为IPv4设计，所以需要特别设计填充。&lt;/p>&lt;p>大端字节序：&lt;/p>&lt;p>假设内存地址是: 0x20, 0x21,0x22,0x23&lt;/p>&lt;p>那么0x12345678如果是高位在低地址&lt;/p>&lt;p>0x20 放0x12 //最高位放入地址的最低位&lt;/p>&lt;p>0x21 放0x34&lt;/p>&lt;p>0x22放 0x56&lt;/p>&lt;p>0x23放0x57&lt;/p>&lt;p>这种叫大端序也叫网络字节序。&lt;/p>&lt;p>系统有四个函数帮助转换字节序：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">short&lt;/span> &lt;span style="color:#a6e22e">htons&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">short&lt;/span>); &lt;span style="color:#75715e">//为端口转换&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">short&lt;/span> &lt;span style="color:#a6e22e">ntohs&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">short&lt;/span>); &lt;span style="color:#75715e">// 为端口转换&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">htonl&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>); &lt;span style="color:#75715e">//IP地址&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">ntohl&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>); &lt;span style="color:#75715e">//IP地址转换&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// h表示主机字节序&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// n表示网络字节序&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>服务器端的IP的目的在于，一台主机可以有多个NIC，添加了IP后就会决定接收该IP的数据。如果只有一个IP地址，直接使用INADDR_ANY。&lt;/p>&lt;h3 id="tcp套接字的io缓冲">TCP套接字的I/O缓冲&lt;/h3>&lt;p>write和read，write调用瞬间将数据移至输出缓冲，read函数掉用瞬间从输入缓冲读取数据。&lt;/p>&lt;ul>&lt;li>I/O缓冲在每个TCP套接字中单独存在。&lt;/li>&lt;li>I/O缓冲在创建套接字时自动生成。&lt;/li>&lt;li>即使关闭套接字也会继续传递输出缓冲中遗留的数据。&lt;/li>&lt;li>关闭套接字将丢失输入缓冲中的数据。&lt;/li>&lt;/ul></description></item><item><title>From Hexo to Hugo</title><link>https://laujay.com/posts/from-hexo-to-hugo/</link><pubDate>Sat, 22 Feb 2020 12:49:17 +0800</pubDate><guid>https://laujay.com/posts/from-hexo-to-hugo/</guid><description>&lt;p>我之前使用hexo静态博客生成器，并使用Travis CI(Continuous Integration)来自动生成并部署静态页面到GitHub Pages。&lt;/p>&lt;p>但是这有两个个问题:&lt;/p>&lt;pre>&lt;code>1. Node很麻烦，我经常装都会遇到问题。2. 不快&lt;/code>&lt;/pre>&lt;p>正好有时间，我决定尝试更换为&lt;a href="https://gohugo.io/">hugo&lt;/a>, 搜索资料后开始行动。&lt;/p>&lt;blockquote>&lt;p>这篇文章基于Claudio Jolowicz的文章&lt;a href="https://cjolowicz.github.io/posts/hosting-a-hugo-blog-on-github-pages-with-travis-ci/">Hosting a Hugo blog on GitHub Pages with Travis CI&lt;/a>&lt;/p>&lt;/blockquote>&lt;h2 id="总览">总览&lt;/h2>&lt;p>总的来说你需要做以下几件事:&lt;/p>&lt;pre>&lt;code>1. 两个github库一个叫&amp;lt;username&amp;gt;.github.io, 一个叫啥都行推荐是blog2. 创建个新的github账号，建议叫&amp;lt;username&amp;gt;-blog-bot3. 并把&amp;lt;username&amp;gt;-blog-bot设置为&amp;lt;username&amp;gt;.github.io这个库的协作者4. 设置Trvais CI，以便blog库有变更会自动生成静态页面并部署&lt;/code>&lt;/pre>&lt;h2 id="先将两个github仓库创建好">先将两个github仓库创建好&lt;/h2>&lt;p>略&lt;/p>&lt;h2 id="接着创建好新的github账号">接着创建好新的GitHub账号&lt;/h2>&lt;p>这里要说下，由于GitHub帐户必须具有唯一的电子邮件地址，因此你需要为机器人帐户使用单独的电子邮件地址。在这种情况下，一种有用的技术是子地址寻址（也称为plus addressing）：&lt;/p>&lt;pre>&lt;code>附加+blog-bot到电子邮件地址的@标志前的部分，那么发送到该地址的邮件将传递到+号前的收件箱中。&lt;/code>&lt;/pre>&lt;p>设置好了后到username.github.io的setting里加为协作者&lt;/p>&lt;h2 id="安装hugo">安装hugo&lt;/h2>&lt;p>mac OSX &lt;code>brew install hugo&lt;/code>其他参见&lt;a href="https://gohugo.io/getting-started/installing/">安装Hugo&lt;/a>&lt;/p>&lt;h2 id="设置博客库">设置博客库&lt;/h2>&lt;p>在你的电脑上 &lt;code>hugo new site blog&lt;/code>&lt;/p>&lt;pre>&lt;code>cd bloggit initgit add .git commit -m &amp;quot;Initial commit&amp;quot;&lt;/code>&lt;/pre>&lt;p>然后 &lt;code>git remote add https://github.com/username/blog.git&lt;/code>接着&lt;/p>&lt;pre>&lt;code>git submodule add \ https://github.com/budparr/gohugo-theme-ananke.git \ themes/anankegit add .git commit -m &amp;quot;Add submodule themes/ananke&amp;quot;&lt;/code>&lt;/pre>&lt;p>这里我简单选择hugo入门里推荐的这个主题, 你可以自己换个。最后 &lt;code>git psuh -u origin master&lt;/code>&lt;/p>&lt;p>将them变成你的子模块后，就可以跟踪最新的了。&lt;/p>&lt;h2 id="配置站点">配置站点&lt;/h2>&lt;p>配置在config.toml文件，主要的几个配置是&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">baseURL&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;https://username.github.io/&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">languageCode&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;zh-CN&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;我的博客&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">theme&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;ananke&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>改完记得提交&lt;/p>&lt;h2 id="链接部署库">链接部署库&lt;/h2>&lt;p>还是blog目录下:&lt;/p>&lt;pre>&lt;code>git submodule add \ https://github.com/username/username.github.io.git \ publicgit commit -am &amp;quot;Add submodule public&amp;quot;&lt;/code>&lt;/pre>&lt;p>public 是最后生成的静态文件所在目录，把它跟要放的存储库关联，那么之后生成好了。只要进这个目录&lt;code>git push origin master&lt;/code>就会把网站部署好了&lt;/p>&lt;h2 id="ci">CI&lt;/h2>&lt;p>利用CI的持续部署解放自己，我们只要&lt;/p>&lt;ul>&lt;li>hugo new posts/postname.md&lt;/li>&lt;li>git add content/posts&lt;/li>&lt;li>git commit -m &amp;ldquo;add post&amp;rdquo;&lt;/li>&lt;li>git push&lt;/li>&lt;/ul>&lt;p>这四个步骤就完成了一个博客文章从写到网站的所有过程&lt;/p>&lt;p>将更改（例如新文章）部署到博客实际需要几个步骤：&lt;/p>&lt;ol>&lt;li>将新文章更改推送到blog存储库。也就是上面这段&lt;/li>&lt;li>hugo被触发重建网站内容。&lt;/li>&lt;li>内容被推送到username.github.io存储库。&lt;/li>&lt;li>该存储库已部署到GitHub Pages。&lt;/li>&lt;/ol>&lt;p>好，接下来设置CI解决2，3两个步骤&lt;/p>&lt;p>在Travis CI(网址是travis-ci.org)上，用GitHub主账号登陆，找到blog这个存储库。找到设置有个叫&lt;code>environments&lt;/code>的地方,添加一个名为的&lt;code>GITHUB_AUTH_SECRET&lt;/code>环境变量。使用新创建的GitHub帐户的用户名和密码将值设置为https://user:password@github.com&lt;/p>&lt;p>在本地blog库的目录下添加文件名为&lt;code>.travis.yml&lt;/code> 的配置文件来配置Travis CI 。&lt;/p>&lt;p>blog存储库的持续集成需要执行三个任务：&lt;/p>&lt;ol>&lt;li>将Hugo安装到CI环境中。&lt;/li>&lt;li>调用Hugo命令行工具来重建站点。&lt;/li>&lt;li>将新内容部署到username.github.io。&lt;/li>&lt;/ol>&lt;p>第三步委托给Shell脚本，这是下一部分的主题。&lt;/p>&lt;p>创建.travis.yml具有以下内容的文件：&lt;/p>&lt;pre>&lt;code>---install: - curl -LO https://github.com/gohugoio/hugo/releases/download/v0.64.1/hugo_0.64.1_Linux-64bit.deb - sudo dpkg -i hugo_0.64.1_Linux-64bit.debscript: - hugodeploy: - provider: script script: bash deploy.sh skip_cleanup: true on: branch: master&lt;/code>&lt;/pre>&lt;h2 id="添加部署脚本">添加部署脚本&lt;/h2>&lt;p>在blog存储库中创建脚本，记得把下面的username替换为你的GitHub用户名：&lt;/p>&lt;pre>&lt;code>#!/bin/bashecho -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;cd publicif [ -n &amp;quot;$GITHUB_AUTH_SECRET&amp;quot; ]then touch ~/.git-credentials chmod 0600 ~/.git-credentials echo $GITHUB_AUTH_SECRET &amp;gt; ~/.git-credentials git config credential.helper store git config user.email &amp;quot;username-blog-bot@users.noreply.github.com&amp;quot; git config user.name &amp;quot;username-blog-bot&amp;quot;figit add .git commit -m &amp;quot;Rebuild site&amp;quot;git push --force origin HEAD:master&lt;/code>&lt;/pre>&lt;h2 id="最后">最后&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> git add .travis.yml deploy.sh&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> git commit -am &lt;span style="color:#e6db74">&amp;#34;CI: Build and push to username.github.io&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> git push&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样你访问https://username.github.io就能看到你的博客了&lt;/p>&lt;p>嗯，至于怎么加文章，自己去看hugo入门吧&lt;/p></description></item><item><title>理解Python的切片表示</title><link>https://laujay.com/posts/slice/</link><pubDate>Fri, 30 Aug 2019 10:20:13 +0800</pubDate><guid>https://laujay.com/posts/slice/</guid><description>&lt;p>原文&lt;a href="https://stackoverflow.com/questions/509211/understanding-slice-notation">understanding-slice-notaion&lt;/a>&lt;/p>&lt;p>它非常简单:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 译者：切片用数学的区间表示的说法都是左开右闭的 [),即含左不含右&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a[start:stop] &lt;span style="color:#75715e"># 取从start到stop-1&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a[start:] &lt;span style="color:#75715e"># 取start到a的最后一个元素&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a[:stop] &lt;span style="color:#75715e"># 取第0个到stop-1个元素&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a[:] &lt;span style="color:#75715e"># 复制整个list&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还有个step(步长)的值,可以一起用:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>a[start:stop:step] &lt;span style="color:#75715e"># 从start开始包含start，到stop-1为止，取每隔step个的元素&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 译者注:&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>,&lt;span style="color:#ae81ff">5&lt;/span>]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a[&lt;span style="color:#ae81ff">0&lt;/span>:&lt;span style="color:#ae81ff">4&lt;/span>:&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> a[&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要记住的关键点是&lt;code>:stop&lt;/code>值表示不在所选中的元素中的第一值,所以stop和start他们之差是选择的元素的数量(如果step是默认值1)&lt;/p>&lt;!-- raw HTML omitted -->&lt;p>另一个特征是start或stop可能是负数，这意味着它从list的末尾而不是开头开始计数。所以:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>a[&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#75715e"># 最后一个元素&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a[&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>:] &lt;span style="color:#75715e"># 最后两个元素&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#75715e"># 去除最后两个元素的数组&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 译者注: 其实就是 a[:len(a) + (-2)]&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>,&lt;span style="color:#ae81ff">5&lt;/span>]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同样，step可能是负数：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>a[::&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#75715e"># 复制整个数组，以倒序复制&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a[&lt;span style="color:#ae81ff">1&lt;/span>::&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#75715e"># 复制从index为1往前的到开头，倒序复制&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#75715e"># 复制从-3开始结尾的元素, 倒序复制&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a[&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>::&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#75715e"># 复制从-3到开头的元素，倒序复制&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Python对程序员很友好，如果你list越界了。例如，如果取a[:-2]但是a只有一个元素，你会得到一个空的list而不是一个错误。有时候你更喜欢错误，而不是这种隐晦的结果，那么你必须要知道会有这种情况。&lt;/p>&lt;h3 id="与slice对象的关系">与slice对象的关系&lt;/h3>&lt;p>切片运算符 &lt;code>[]&lt;/code> 实际上在上面的代码中通过 &lt;code>:&lt;/code> 使用了一个slice()对象(只在[]内有效)，例如：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>a[start:stop:step]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>等价于&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>a[slice(start, stop, step)]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Slice对象根据不同的参数会有不同的行为,跟range非常类似，比如 &lt;code>slice(stop)&lt;/code> 和&lt;code>slice(start, stop[, step])&lt;/code>。如果要跳过给定的参数，可以使用&lt;code>None&lt;/code>, 例如 &lt;code>a[start:]&lt;/code> 等价于 &lt;code>a[slice(start, None)]&lt;/code> 或者 &lt;code>a[::1]&lt;/code> 等价于&lt;code>a[slice(None, None, -1)]&lt;/code>&lt;/p>&lt;p>虽然基于 &lt;code>:&lt;/code> 符号的对于简单切片非常有用，但是显式使用slice()对象简化了使用切片时自动生成slice()对象。&lt;/p></description></item><item><title>Three Years</title><link>https://laujay.com/posts/three-years/</link><pubDate>Sat, 06 Jul 2019 15:22:13 +0800</pubDate><guid>https://laujay.com/posts/three-years/</guid><description>&lt;p>哇，终于到三年了, 时间真是可怕的东西。不知不觉已经毕业三年了，感觉自己昨天才毕业 &lt;del>装嫩&lt;/del>。&lt;/p>&lt;h2 id="工作上">工作上&lt;/h2>&lt;p>就在写完两周年总结后，我换了工作，这份工作的面试经历也是很有意思的。&lt;/p>&lt;p>第一次电话面试的方式搞定所有轮次的面试, 第一次遇到面试会问编译原理的面试官。在复试被面的怀疑人生的同时，才发现自己需要学的太多太多了，有幸能遇到这么重视基础的面试官再次提醒了自己基础的重要性。&lt;/p>&lt;p>面试完后，我从HR处得知，电话面的原因其实是，公司的技术团队目前都在马来西亚闭关修炼呢。我也是个傻大胆，就觉着出去看看也好，没觉得有啥危险，就同意去马来了，😊主要是我天朝太安全了没反应过来。到了后同事说我，胆子这么大谁都不认识就敢跑来。18年底回国后在深圳的办公室呆了半年，19年七月初又来马来西亚了，免去了深圳的通勤，还是很爽的。&lt;/p>&lt;h2 id="学习上">学习上&lt;/h2>&lt;p>面试被虐后，就开始注意补充基础知识了。学习了极客时间上的不少课程，非常推荐趣学网络，数据结构与算法之美以及左耳朵听风。并且阅读的书籍改为一些设计，架构，底层原理类的了。而不是各种框架各种技术的书。英语上按照左耳听风里的在做，并且加大了刷YouTube的时间，很多英文的英语教学视频难度不高，但是很好听懂，老师讲的也很好。听多了后自我感觉听力有所长进。&lt;/p>&lt;h2 id="生活上">生活上&lt;/h2>&lt;p>第一次出国兼坐飞机，第一次吃榴莲，第一次在国外吃火锅，太多了。在马来西亚呆了5个月不到,很有意思的经历，明明在国外，却到处是说普通话的华人以及会说普通话的老外。有些当地人虽然不会说可是却能听懂。语言上不是很大的障碍，很快就消除了陌生感以及不适应。不工作的时候就拉着同事去尝试各种食物，幸好拉着的老司机英语还是很可以的，点菜全靠他了。这次给我最大的感受是马来西亚人好少，空气好好，生活节奏超级慢。然后激发了一个英语渣学英语的心，毕竟世界这么大我想去看看呢。&lt;/p>&lt;p>Jay&lt;/p>&lt;p>2019-07-06&lt;/p>&lt;p>于马来西亚&lt;/p></description></item><item><title>Python中的正则基础</title><link>https://laujay.com/posts/re-basic/</link><pubDate>Fri, 26 Apr 2019 10:00:17 +0800</pubDate><guid>https://laujay.com/posts/re-basic/</guid><description>&lt;h2 id="python中的re">Python中的re&lt;/h2>&lt;h3 id="元字符总览">元字符总览&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">.&lt;/span> &lt;span style="color:#f92672">^&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">?&lt;/span> { } [ ] \ &lt;span style="color:#f92672">|&lt;/span> ( )&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="和">&lt;code>[&lt;/code>和&lt;code>]&lt;/code>&lt;/h3>&lt;p>指定字符类， 含义是范围，匹配一组字符 &lt;code>[a-z]&lt;/code>表示所有小写字母。字符类里其他元字符不生效，在字符类里元字符被剥夺特殊性。反字符类:&lt;code>[^5]&lt;/code> 匹配除了 5外任何字符 &lt;code>^&lt;/code>必须是字符类第一个字符，不然无取反的作用。&lt;/p>&lt;h3 id="heading">&lt;code>\&lt;/code>&lt;/h3>&lt;p>反斜杠后加其他字符的组合特指特殊序列，也用于转义。要取消本身含义需要&lt;code>'\\'&lt;/code>。&lt;code>\w&lt;/code>匹配任何字母数字字符，note：依据正则表达式模式的不同，分为以字节类和Unicodedata模块中标记为字母的所有字符。在编译时提供&lt;code>re.ASCII&lt;/code>可以表示更受限制的&lt;code>\w&lt;/code>定义。&lt;/p>&lt;table>&lt;thead>&lt;tr>&lt;th>类型&lt;/th>&lt;th>含义&lt;/th>&lt;/tr>&lt;/thead>&lt;tbody>&lt;tr>&lt;td>&lt;code>\d&lt;/code>&lt;/td>&lt;td>任何十进制数字；这等价于类 [0-9]&lt;/td>&lt;/tr>&lt;tr>&lt;td>&lt;code>\D&lt;/code>&lt;/td>&lt;td>匹配任何非数字字符；这等价于类 [^0-9]&lt;/td>&lt;/tr>&lt;tr>&lt;td>&lt;code>\s&lt;/code>&lt;/td>&lt;td>匹配任何空白字符；这等价于类 [ \t\n\r\f\v]&lt;/td>&lt;/tr>&lt;tr>&lt;td>&lt;code>\S&lt;/code>&lt;/td>&lt;td>匹配任何非空白字符；这相当于类 [^ \t\n\r\f\v]&lt;/td>&lt;/tr>&lt;tr>&lt;td>&lt;code>\w&lt;/code>&lt;/td>&lt;td>匹配任何字母与数字字符；这相当于类 [a-zA-Z0-9_]&lt;/td>&lt;/tr>&lt;tr>&lt;td>&lt;code>\W&lt;/code>&lt;/td>&lt;td>匹配任何非字母与数字字符；这相当于类 [^a-zA-Z0-9_]&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table>&lt;h3 id="repeat">Repeat&lt;/h3>&lt;p>&lt;code>*&lt;/code> 匹配前一个字符0～多次， 贪婪的例子： a[bcd]*b ,匹配类&lt;code>[bcd]&lt;/code>中的零或多个字母&lt;code>+&lt;/code> 匹配前一个字符1～多次&lt;code>?&lt;/code> 匹配0～1词&lt;code>{m,n}&lt;/code> 至少重复m次，最多n次。省略的话会m会是默认0，n为无限。&lt;/p>&lt;h3 id="应用匹配">应用匹配&lt;/h3>&lt;table>&lt;thead>&lt;tr>&lt;th>方法/属性&lt;/th>&lt;th>目的&lt;/th>&lt;th>&lt;/th>&lt;/tr>&lt;/thead>&lt;tbody>&lt;tr>&lt;td>match()&lt;/td>&lt;td>确定正则是否从字符串的开头匹配&lt;/td>&lt;td>&lt;/td>&lt;/tr>&lt;tr>&lt;td>search()&lt;/td>&lt;td>扫描字符串，查找此正则匹配的任何位置。&lt;/td>&lt;td>&lt;/td>&lt;/tr>&lt;tr>&lt;td>findall()&lt;/td>&lt;td>找到正则匹配的所有子字符串，并将它们作为列表返回。&lt;/td>&lt;td>&lt;/td>&lt;/tr>&lt;tr>&lt;td>finditer()&lt;/td>&lt;td>找到正则匹配的所有子字符串，并将它们返回为一个 &lt;a href="https://docs.python.org/zh-cn/3/glossary.html#term-iterator">iterator&lt;/a>&lt;/td>&lt;td>&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table></description></item><item><title>git pre-commit workflow</title><link>https://laujay.com/posts/git-pre-commit/</link><pubDate>Wed, 06 Mar 2019 20:14:29 +0800</pubDate><guid>https://laujay.com/posts/git-pre-commit/</guid><description>&lt;blockquote>&lt;p>之前看了程序人生的一篇code is law，做了点小小的实践。想起在QQ群看到一个人的分享截图，于是就想将之前做的实践查到的资料删减翻译下整理成文章，如果万一有团队内部的技术分享会还是可以分享下的。&lt;/p>&lt;/blockquote>&lt;p>我想遵循pep8，我不想手动格式化代码，我不想每次手动执行flake8来检查，甚至我不想手动执行mypy去检查我代码。&lt;/p>&lt;p>那么有什么办法呢，作为开发，日常最常执行的操作git commit必然是其中之一，无论是通过IDE的GUI工具还是命令行的方式。&lt;/p>&lt;p>通过git提供的pre-commit的hook可以在commit的时候将代码格式化，规范检查，测试等执行完毕，而不需要工程师手动做相关的操作。流程类似这样的：&lt;/p>&lt;p>&lt;img src="https://ljvmiranda921.github.io/assets/png/tuts/precommit_pipeline.png" alt="workflow">&lt;/p>&lt;p>通过采用&lt;em>pre-commit&lt;/em> 这个Python编写的库只需要以下几步就可以完成上述任务。&lt;/p>&lt;ul>&lt;li>&lt;code>pipenv install -dev pre-commit&lt;/code>&lt;/li>&lt;li>编辑.pre-commit-config.yaml&lt;/li>&lt;li>执行pre-commit install 以便在.git/目录中安装git hooks&lt;/li>&lt;/ul>&lt;!-- raw HTML omitted -->&lt;p>比如你想用black格式化代码，flak8检查代码规范，单元测试那么例子如下：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">repos&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repo&lt;/span>: &lt;span style="color:#ae81ff">local&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">hooks&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">black&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">black&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">language&lt;/span>: &lt;span style="color:#ae81ff">system&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">entry&lt;/span>: &lt;span style="color:#ae81ff">black&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">types&lt;/span>: [&lt;span style="color:#ae81ff">python]&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">flake8&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">flake8&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">language&lt;/span>: &lt;span style="color:#ae81ff">system&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">entry&lt;/span>: &lt;span style="color:#ae81ff">flake8&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">types&lt;/span>: [&lt;span style="color:#ae81ff">python]&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">unitest&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">unitest&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">language&lt;/span>: &lt;span style="color:#ae81ff">system&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">entry&lt;/span>: &lt;span style="color:#ae81ff">./test.sh&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">types&lt;/span>: [&lt;span style="color:#ae81ff">python]&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>repos是顶层的，每个hook都可以增加一个repo的section。repo存储库映射告诉pre-commit从哪里获取提现实现好的hook比如这里的flake8可以改为远程的https://github.com/pre-commit/pre-commit-hooks在上面这个例子中，由于我都在本地装了entry对应的文件，所以直接使用localentry 表示可执行的文件或者命令types 表示对哪些文件的更改起作用language 表示hook是哪些语言实现的，这里直接偷懒用系统,让他自己找&lt;/p>&lt;p>有时候我们自己的标注和pep8的略有不同，那么可以在当前目录下增加 &lt;code>.flake8&lt;/code> 来告诉flake8我们自己的客制化。&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#a6e22e">flake8&lt;/span>]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ignore&lt;/span> = &lt;span style="color:#a6e22e">E203&lt;/span>, &lt;span style="color:#a6e22e">E266&lt;/span>, &lt;span style="color:#a6e22e">E501&lt;/span>, &lt;span style="color:#a6e22e">W503&lt;/span>, &lt;span style="color:#a6e22e">F403&lt;/span>, &lt;span style="color:#a6e22e">F401&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">max-line-length&lt;/span> = &lt;span style="color:#ae81ff">79&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">max-complexity&lt;/span> = &lt;span style="color:#ae81ff">18&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">select&lt;/span> = &lt;span style="color:#a6e22e">B&lt;/span>,&lt;span style="color:#a6e22e">C&lt;/span>,&lt;span style="color:#a6e22e">E&lt;/span>,&lt;span style="color:#a6e22e">F&lt;/span>,&lt;span style="color:#a6e22e">W&lt;/span>,&lt;span style="color:#a6e22e">T4&lt;/span>,&lt;span style="color:#a6e22e">B9&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>&lt;li>本文章原文及本文的图片来自&lt;a href="https://ljvmiranda921.github.io/notebook/2018/06/21/precommits-using-black-and-flake8/">这里&lt;/a> 版权归原作者所有&lt;/li>&lt;/ul></description></item><item><title>Env is Evil: ycmd server SHUT DOWN Unexpected exit code -11</title><link>https://laujay.com/posts/env-is-evil/</link><pubDate>Tue, 27 Nov 2018 07:30:01 +0800</pubDate><guid>https://laujay.com/posts/env-is-evil/</guid><description>&lt;h2 id="what-issue">What issue?&lt;/h2>&lt;p>The ycmd server SHUT DOWN (restart with &amp;lsquo;:YcmRestartServer&amp;rsquo;). Unexpected exit code -11.&lt;/p>&lt;h2 id="try-fix">Try fix&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>./install.py --clang-completer&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd ~/.vim/bundle/YouCompleteMe/third_party/ycmd&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd ycmd&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp default_settings.json ..&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python ycmd --options_file default_settings&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python3 ./build.py&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Not working.&lt;/p>&lt;p>When reading source code, I found out the &lt;code>build.py&lt;/code> uses sysconfig.I try to add pdb.set_trace() in the first line of function GetPossiblePythonLibraryDirectories.In pdb shell p sysconfig.get_config_var(&amp;ldquo;LIBPL&amp;rdquo;), result show path is fault, not mine.I try hard code absolute path in GetPossiblePythonLibraryDirectories, but no working.&lt;/p>&lt;h2 id="fixed">Fixed&lt;/h2>&lt;p>Anyway, in ycm issues i found out miniconda3 has conflict issue.&lt;/p>&lt;p>so try:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>rm &lt;span style="color:#f92672">-&lt;/span>rf miniconda3&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python3 install&lt;span style="color:#f92672">.&lt;/span>py&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Well, it&amp;rsquo;s working.Environment implicit is evil, explicit is better than implicit.&lt;/p></description></item><item><title>ASGI规范中文版</title><link>https://laujay.com/posts/asgi-zh-cn/</link><pubDate>Wed, 17 Oct 2018 07:00:39 +0800</pubDate><guid>https://laujay.com/posts/asgi-zh-cn/</guid><description>&lt;h1 id="异步服务网关接口asynchronous-server-gateway-interface-规范">异步服务网关接口(Asynchronous Server Gateway Interface) 规范&lt;/h1>&lt;p>&lt;em>Version&lt;/em>:2.0(2017-11-28)&lt;/p>&lt;h2 id="摘要">摘要&lt;/h2>&lt;p>本文档描述了基于网络协议服务器（尤其是web服务器）和 Python 应用之间的标准接口，希望能够处理多种通用协议(包括 HTTP、HTTP2 和 WebSocket)。&lt;/p>&lt;p>这个基本规范目的在于定义这些服务器交互并运行应用的API集合；每个支持的协议（例如HTTP) 都有一个子规范，概述如何将协议编码和解码报文。&lt;/p>&lt;h2 id="依据">依据&lt;/h2>&lt;p>WSGI 规范自诞生以来应用广泛，让 Python 框架和 web 服务器的选择上有很大的自由。然而，因为设计的与 HTTP 风格的请求响应模型的耦合太强，加上越来越多不遵循这种模式的协议逐渐成为 web 编程的标准之一，比如说，WebSocket。ASGI 尝试在保证应用接口简单的前提下，提供一个允许数据能够在任意时候、被任意应用进程发送和接受的抽象。&lt;/p>&lt;p>它同样采用将协议转换为Python兼容，异步友好的消息集的原则，并将其概括为两部分：一个关于构建服务器的标准通信接口，以及一组用于每个协议的标准通信协议。&lt;/p>&lt;p>它主要的目标是提供一个编写HTTP/2 和WebSocket，以及一般的HTTP应用代码的方式。然而，&lt;/p>&lt;p>这种设计一部分是确保有简单的途径来兼容现有的WSGI服务器与应用代码，为绝大多数依赖WSGI的Python web 项目提供一个继续运行的简单方式，这是很重要的一点。具体的细节在ASGI-HTTP规范里描述。&lt;/p>&lt;h2 id="总览">总览&lt;/h2>&lt;p>ASGI由两个不同的组件组成&lt;/p>&lt;ul>&lt;li>一个&lt;em>协议服务&lt;/em> ，其用来终止sockets与转换他们成为一个连接于每个连接的事件信息&lt;/li>&lt;li>一个&lt;em>应用代码&lt;/em> ，它位于协议服务内，每个连接都会实例化一次，并在事件发生时进行处理&lt;/li>&lt;/ul>&lt;p>与WSGI类似的是，应用运行于服务容器中，服务容器以标准格式向应用发送请求。然而与WSGI不同的是，应用是实例化的对象，他们是处理事件，而非简单可调用的，并且他们必须是兼容&lt;code>asyncio&lt;/code>的协程（在主线程上，如果需要运行同步的代码，可以自由的使用线程或其他进程）&lt;/p>&lt;p>与WSGI不同的是，一个ASGI有两个独立的连接部分：&lt;/p>&lt;ul>&lt;li>&lt;em>连接域&lt;/em> ，代表着一个协议连接到一个用户，并持续到连接被关闭&lt;/li>&lt;li>事件，发生在连接时发送给应用&lt;/li>&lt;/ul>&lt;p>应用在一个连接域内被实例化，然后在事件循环中被触发执行处理事件，最后发送数据给客户端。&lt;/p>&lt;p>每个应用实例都映射到一个独立的“socket”或者连接，如果要进行清理操作，预计会在该连接的预设生存期再加一段时间。 有些协议可能不使用传统的套接字; ASGI针对这些协议将定义范对应的（实例）生命域以及何时关闭。&lt;/p>&lt;h2 id="规范细节">规范细节&lt;/h2>&lt;h3 id="连接域">连接域&lt;/h3>&lt;p>用户到ASGI应用的每个连接都将产生一个应用实例。连接的持续域与建立连接时获得得信息，统称为&lt;em>连接域&lt;/em>。&lt;/p>&lt;p>例如： 在HTTP连接域下只会持续一个请求，但是它已经包含大多数的请求信息(除了HTTP request body外，因为它通过流来传递事件)。&lt;/p>&lt;p>但是，在WebSocket协议里，只要socket连着，连接就会不断持续着。这个域包含的信息像是Websocket的路径，但是传入的信息等细节则是以事件的形式出现的。&lt;/p>&lt;p>有些协议可能会提供一个连接，但只有非常有限的信息，因为他们封装了握手之类的东西。每个协议定义都必须包含关于连接持续多长的信息，与能从中获得哪种类型的信息。&lt;/p>&lt;p>应用程序在被初始化与给定连接域时不能与客户端进行通信；他们必须等待到事件循环根据协议规范运行，可能必须等到初次打开的信息。&lt;/p>&lt;h2 id="事件">事件&lt;/h2>&lt;p>ASGI将协议分解为一系列应用程序必须响应的&lt;em>事件&lt;/em>，这有序的两个事件很简单-&lt;code>http.request&lt;/code>与&lt;code>http.disconnect&lt;/code>。针对像WebSocket，可能是&lt;code>websocket.connect，websocket.send，websocket.receive，websocket.disconnect&lt;/code>。&lt;/p>&lt;p>每个事件都是一个&lt;code>dict&lt;/code>并带着一个顶层&lt;code>type&lt;/code>key，包含信息类型的一个unicode 字符串。使用者可以自由的建立他们自己的消息类型，并在应用实例间发送他们以处理高级事件-举个例子，一个聊天程序可能会发送一个&lt;code>mychat.message&lt;/code>类型的聊天信息。预估应用程序可以处理多种事件类型混合的事件集，其中一些来自客户端连接，另外一些则来自应用的其它部分。&lt;/p>&lt;p>因为这些信息可能来自其它网络，他们需要被序列化，因此信息被要求只能包含以下几种类型：&lt;/p>&lt;ul>&lt;li>Byte strins&lt;/li>&lt;li>Unicode strings&lt;/li>&lt;li>Integers (within the signed 64 bit range)&lt;/li>&lt;li>Floating point numbers (within the IEEE 754 double precision range, no &lt;code>Nan&lt;/code> or infinities)&lt;/li>&lt;li>Lists (tuples should be encoded as lists)&lt;/li>&lt;li>Dicts (keys must be unicode strings)&lt;/li>&lt;li>Booleans&lt;/li>&lt;li>&lt;code>None&lt;/code>&lt;/li>&lt;/ul>&lt;h2 id="应用">应用&lt;/h2>&lt;p>ASGI应用被定义成可调用的:&lt;/p>&lt;p>&lt;code>application(scope)应用（域）&lt;/code>&lt;/p>&lt;ul>&lt;li>&lt;code>域&lt;/code>: 连接域，一个至少包含一个&lt;code>type&lt;/code>key所指定传入协议的字典&lt;/li>&lt;/ul>&lt;p>每当一个新的连接进入协议服务器，这个第一个可调用的对象在有新连接时会被调用并建立一个新的&lt;em>实例&lt;/em> （这个实例时一个新的对象，第一次被调用时候返回）&lt;/p>&lt;p>这个调用时一个同步的，且不同包含阻塞调用（建议只作为存储的域）。假如你需要执行阻塞的工作，则必须在下一个可以调用的开始时执行它，然后你的应用才会进入await等待事件执行完。&lt;/p>&lt;p>他必须返回另一个，awaitable的调用：&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>协程 application_instance(receive, send)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>&lt;li>&lt;p>&lt;code>receive&lt;/code>，一个awaitable调用的函数，当可用的时候他会&lt;code> yield&lt;/code> 一个新的事件字典事件&lt;/p>&lt;/li>&lt;li>&lt;p>&lt;code>send&lt;/code>, 一个awaitable调用的单个事件字典作为一个位置参数，一但发送完成就会返回&lt;/p>&lt;/li>&lt;/ul>&lt;p>这个设计也许更容易被认为是一个可能的实现，像是一个类:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Python" data-lang="Python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Application&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __init__(self, scope):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>scope &lt;span style="color:#f92672">=&lt;/span> scope&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> __call__(self, receive, send):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>应用程序接口一般情况下传入两个可调用对象，看起来会像是工厂函数(类)或者是基于分配器来提供更好的可扩展性。&lt;/p>&lt;p>无论scope或者你接收或发送的报文格式都是基于应用协议的。scope必须是一个dict，键scope[&amp;ldquo;type&amp;rdquo;]始终存在，并可用于确定使用的协议类型。&lt;/p>&lt;p>协议特定的子规范包含了这些scope和报文的格式。他们相当于WSGI规范定义的字典中的&lt;code>environ&lt;/code>键。&lt;/p>&lt;h2 id="协议规范">协议规范&lt;/h2>&lt;p>这里描述各种协议的标准化域和报文格式。&lt;/p>&lt;p>一个在所有的域和报文中都存在的公共键是&lt;code>type&lt;/code>, 用于表明正在接收哪种类型的域或者报文。&lt;/p>&lt;p>在域中，&lt;code>type&lt;/code>键必须是一个unicode字符串，像是&amp;quot;http&amp;quot;或者是&amp;quot;websocket&amp;quot;,如相关协议规范中的定义所示。&lt;/p>&lt;p>在 报文中，类型应命名为&lt;code>protocol.message_type&lt;/code>，其中协议与域类型匹配，&lt;code>message_type&lt;/code>由协议规范定义。消息类型值的示例包括&lt;code>http.request&lt;/code>和&lt;code>websocket.send&lt;/code>&lt;/p>&lt;p>当前协议规范:&lt;/p>&lt;ul>&lt;li>&lt;a href="https://github.com/django/asgiref/blob/master/specs/www.rst">HTTP and WebSocket&lt;/a>&lt;/li>&lt;/ul>&lt;h2 id="中间件">中间件&lt;/h2>&lt;p>有可能会有ASGI中间件，代码同时具有服务器和应用两种角色， 又接受一个域和发送/接收的awaitables，可能修改这个awaitables，然后调用更底层的应用。&lt;/p>&lt;p>当一个中间件修改域的时候，应该要在域对象的副本进行改变，并将副本传入底层应用之前进行修改，否则更改可能影响上层。需要注意的是，您不应该假设您传给应用的域的副本是其最终使用的域的副本，因为底层可能是其他中间件；因此，不要保留对它的引用，并尝试将它改变为传递的初始ASGI构造器可调用的的域。&lt;/p>&lt;p>值得注意的是，ASGI应用的一部分域同步运行，它的目的在于与Python类构造函数兼容。如果你需要将对象放入阻塞/异步工作的域中，则可以让他们是awaitable的，或着在协程的入口创建可以填写的对象（记住，对象必须是可以修改的；您无法保留对域的引用并尝试稍后添加键）。&lt;/p>&lt;h2 id="错误处理">错误处理&lt;/h2>&lt;p>如果服务器收到一个无效的事件字典-比如，一个未知类型，缺少应该有的键，或者用错了Python对象的类型（比如对于HTTP headers Unicode字符串），它应该抛出一个awaitable的异常 &lt;code>send&lt;/code>给应用。&lt;/p>&lt;p>如果应用收到无效的事件字典，&lt;code>receive&lt;/code>应该引发异常。&lt;/p>&lt;p>在这两种情况下，事件字典中的其他键的存在都不应该引发异常。这是为了允许随着事件的推移对协议规范进行不间断的升级。&lt;/p>&lt;p>服务器可以自由的展示错误，这些错误会从他们正在运行的应用实例中抛出，但是他们希望在控制台打印log，发送到系统日志或者其他操作-但是如果发生这种情况，他们必须终止应用程序实例以及其关连的连接。&lt;/p>&lt;h2 id="扩展">扩展&lt;/h2>&lt;p>有时候基于ASGI协议的服务器可能希望在核心ASGI协议规范之外提供特定服务器的扩展，或者在规范的更改被发布之前进行试运行。&lt;/p>&lt;p>对于这种情况，我们定义了一个通用模式&lt;code>extensions&lt;/code>-对协议规范的名称添加是可选的，但如果由服务器提供并由应用程序解析，则可用于获取更多功能。&lt;/p>&lt;p>这是通过字典中的一个 &lt;code>extensions&lt;/code>字段，其本身值就是一个字典。扩展名由一个在服务器和应用程序之间达成一致的unicode字符串名称。&lt;/p>&lt;p>如果服务器支持扩展名，它应该在&lt;code>extensions&lt;/code>值对应的字典内加入一个扩展名，扩展名对应的值也是一个字典。&lt;/p>&lt;p>服务器可以提供任何额外的域信息，这些信息属于该字典值中扩展的那部分，或者如果扩展只是表明服务器通过&lt;code>send&lt;/code> 可调用函数接受附加事件，则它可能是一个空字典。&lt;/p>&lt;p>一个例子是，假设HTTP协议服务器希望提供一个扩展，允许将新事件发送回尝试通过操作系统刷新网络发送缓存区的服务器。它在扩展字典中提供一个空的字段来表明它可以处理该事件:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>scope &lt;span style="color:#f92672">=&lt;/span> {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http&amp;#34;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;method&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;GET&amp;#34;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;extensions&amp;#34;&lt;/span>: {&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fullflush&amp;#34;&lt;/span>: {},&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果应用获取到这个空字段，它就知道它可以发送自定义事件（通过类型为&lt;code>http.fullflush&lt;/code>的&lt;code>send&lt;/code>调用）。&lt;/p>&lt;h3 id="字符串与unicode">字符串与Unicode&lt;/h3>&lt;p>在本文档和所有子规范中，字节字符串指的是 bytes Python3中的类型。Unicode字符串指的&lt;code>str&lt;/code>是Python3中的类型。&lt;/p>&lt;p>这个文档永远不会指定字符串-所有string都是两种确切类型之一。&lt;/p>&lt;p>所有的字典key（包括域和事件）都是unicode字符串。&lt;/p>&lt;h2 id="version-history">Version History&lt;/h2>&lt;ul>&lt;li>2.0 (2017-11-28): Initial non-channel-layer based ASGI spec&lt;/li>&lt;/ul>&lt;h2 id="copyright">Copyright&lt;/h2>&lt;p>This document has been placed in the public domain.&lt;/p></description></item><item><title>Coroutine</title><link>https://laujay.com/posts/coroutine/</link><pubDate>Sun, 15 Jul 2018 18:20:13 +0800</pubDate><guid>https://laujay.com/posts/coroutine/</guid><description>&lt;h2 id="fluent-python阅读笔记">Fluent Python阅读笔记&lt;/h2>&lt;h2 id="从可迭代对象说起">从可迭代对象说起&lt;/h2>&lt;h3 id="迭代器">迭代器&lt;/h3>&lt;p>使用iter内置函数可以获取迭代器的对象，如果对象实现了&lt;code>__iter__&lt;/code>，而&lt;code>__iter__&lt;/code>一般返回迭代器，那么对象就是可迭代的。序列都可以迭代，实现了&lt;code>__getitem__&lt;/code>方法，并且参数从零开始索引的也可以迭代。&lt;/p>&lt;p>可迭代对象和迭代器之间的关系是: Python从可迭代的对象中获取迭代器。迭代器是实现了无参数&lt;code>__next__&lt;/code>方法的对象，使用next内置方法能返回对象中下个元素并实现了&lt;code>__iter__&lt;/code>，而&lt;code>__iter__&lt;/code>一般返回实例本身，这样可以将迭代器本身当可迭代对象用。可迭代对象一定不能是自身的迭代器，也就是不能实现&lt;code>__next__&lt;/code>方法(反模式)。&lt;/p>&lt;p>所以过程是这样滴：假设有个s = Sentence(&amp;ldquo;Pig and Pepper&amp;rdquo;)it = iter(s)iter -&amp;gt; 调用了&lt;code>__iter__&lt;/code>于是iter返回了s本身next -&amp;gt; 调用了&lt;code>__next__&lt;/code>于是返回序列中下一个&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> Sentence(&lt;span style="color:#e6db74">&amp;#39;Pig and Pepper&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> iter(s)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> next(it)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Pig&amp;#39;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> next(it)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;and&amp;#39;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> next(it)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#39;Pepper&amp;#39;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> next(it)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Traceback (most recent call last):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">StopIteration&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> list(it) &lt;span style="color:#75715e">#&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> list(iter(s)) &lt;span style="color:#75715e"># [&amp;#39;Pig&amp;#39;, &amp;#39;and&amp;#39;, &amp;#39;Pepper&amp;#39;]&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="yield与生成器">yield与生成器&lt;/h3>&lt;p>Python函数的定义体中有yield关键字，该函数就是生成器函数， 生成器函数是生成器工厂，但生成器工厂不是只有包含yield的才是，只要返回一个生成器就是生成器工厂。&lt;/p>&lt;p>生成器是迭代器，会生成传给yield 关键字的表达式的值。因为生成器是迭代器，所以调用next 会获取yield 生成的下一个元素。&lt;/p>&lt;p>在Python 3.3 之前，如果生成器函数中的return 语句有返回值，那么会报错。现在可以这么做，不过return 语句仍会导致 StopIteration 异常抛出。并且调用方可以从异常中获取返回值，这点在把生成器当协程用的时候有意义。&lt;/p>&lt;p>生成器有个语法糖叫生成器表达式：(for i in list)，这种由括号括起来的是创建生成器的简洁句法。&lt;/p>&lt;h3 id="生成器加上send就变协程">生成器加上send就变协程&lt;/h3>&lt;p>大概是引入yield的五年后PEP342为生成器增加了额外的方法和功能，主要是&lt;code>.send()&lt;/code> 与&lt;code>.__next__()&lt;/code> 方法一样，&lt;code>.send()&lt;/code> 方法致使生成器前进到下一个 yield 语句。不 过，&lt;code>.send()&lt;/code> 方法还允许使用生成器的客户把数据发给自己，即不管传给 &lt;code>.send()&lt;/code> 方法什么参数，那个参数都会成为生成器函数。定义体中对应的yield 表达式的值。也就是说，&lt;code>.send()&lt;/code> 方法允许在客户代码和生成器之间双向交换数据。而 .&lt;strong>next&lt;/strong>() 方法只允许客户从生成器中获取数据。&lt;/p>&lt;p>PEP 342 还添加了&lt;code>.throw(...)&lt;/code> 和 &lt;code>.close()&lt;/code> 方法:前者的作用是让调用方抛出异常，在生成器中处理;后者的作用是终止生成器。&lt;/p>&lt;h2 id="协程示例">协程示例&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">simple_coroutine&lt;/span>():&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: print(&lt;span style="color:#e6db74">&amp;#39;-&amp;gt; coroutine startd&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">yield&lt;/span> &lt;span style="color:#75715e"># 只从调用端接收数据&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: print(&lt;span style="color:#e6db74">&amp;#39;-&amp;gt; coroutine received:&amp;#39;&lt;/span>, x)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">3&lt;/span>]: my_coro &lt;span style="color:#f92672">=&lt;/span> simple_coroutine()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">4&lt;/span>]: my_coro&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Out[&lt;span style="color:#ae81ff">4&lt;/span>]: &lt;span style="color:#f92672">&amp;lt;&lt;/span>generator object simple_coroutine at &lt;span style="color:#ae81ff">0x1079f0308&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">5&lt;/span>]: next(my_coro)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span> coroutine startd&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">6&lt;/span>]: my_coro&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#ae81ff">42&lt;/span>) &lt;span style="color:#75715e"># 发送数据给协程&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span> coroutine received: &lt;span style="color:#ae81ff">42&lt;/span> &lt;span style="color:#75715e"># 打印最后一句，函数执行定义体的末尾，抛出StopIteration&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">---------------------------------------------------------------------------&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">StopIteration&lt;/span> Traceback (most recent call last)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>ipython&lt;span style="color:#f92672">-&lt;/span>input&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">13&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">7&lt;/span>c96f97a77cb&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>module&lt;span style="color:#f92672">&amp;gt;&lt;/span>()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">----&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> my_coro&lt;span style="color:#f92672">.&lt;/span>send(&lt;span style="color:#ae81ff">42&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">StopIteration&lt;/span>:&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个是基于生成器的协程，定义体中包含yield协程处于四个状态:&amp;lsquo;GEN_CREATED&amp;rsquo;: 等待开始执行&amp;lsquo;GEN_RUNNING&amp;rsquo;: 解释器正在执行&amp;lsquo;GEN_SUSPENDED&amp;rsquo;: 在yield表达式处暂停&amp;lsquo;GEN_CLOSED&amp;rsquo;: 执行结束&lt;/p>&lt;p>始终要调用 next(my_coro) 激活协程——也可以调用 my_coro.send(None)，效果一样。如果没激活就发送None之外的值会报错:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> Traceback (most recent call last):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File &lt;span style="color:#e6db74">&amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;&lt;/span>, line &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">in&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>module&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">TypeError&lt;/span>: can&lt;span style="color:#e6db74">&amp;#39;t send non-None value to a just-started generator&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="yield-from">yield from&lt;/h2>&lt;p>yield from :• 子生成器产出的值都直接传给委派生成器的调用方(即客户端代码)。• 使用 send() 方法发给委派生成器的值都直接传给子生成器。如果发送的值是 None，那么会调用子生成器的 &lt;code>__next__()&lt;/code> 方法。如果发送的值不是 None，那么会调用子生成器的send() 方法。如果调用的方法抛出 StopIteration 异常，那么委派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。• 生成器退出时，生成器(或子生成器)中的 return expr 表达式会触发 StopIteration(expr)异常抛出。• yield from 表达式的值是子生成器终止时传给 StopIteration 异常的第一个参数。&lt;/p></description></item><item><title>Two Years</title><link>https://laujay.com/posts/two-years/</link><pubDate>Fri, 06 Jul 2018 20:20:13 +0800</pubDate><guid>https://laujay.com/posts/two-years/</guid><description>&lt;p>两年了，总觉得该总结下了。工作一年的时候没啥心思。虽然现在处境不算好，但是内心强大多了。&lt;/p>&lt;hr>&lt;p>2016年的7月4号，是毕业后工作的第一天。记得那天，天气不错，我当时到了后由于没人招待还问了我们公司没人事么，记得很清楚CEO笑着说了句要什么人事。&lt;/p>&lt;p>感谢那些人，大家很好。那时候，大伙没事就去咖啡馆里拿杯咖啡，我经常蹭咖啡，然后被老司机们带喝起了美式，正好我有点乳糖不耐又蛮喜欢苦味的，倒喝的很开心。&lt;/p>&lt;p>有段时间经常周六，或者周日就跑公司的咖啡馆里或者别的附近的咖啡馆里跟一两个同事聊天、学习、加班。那时候很简单，泡壶茶，坐一天。节奏很舒服，环境很舒服。&lt;/p>&lt;p>随着时间的推移，渐渐的我做的和我想做的就开始有偏差了，随着公司的需求写着不同的语言用着不同的框架。不喜欢一个东西就会下意识排斥，于是就变成了下班后学习的和工作完全无关，而实践中用，下班后咀嚼白天的体会查缺补漏，觉得才是很好自我提升的道路。可是我不是这样子的路线，我觉得我需要些改变，于是问自己，我想做什么，擅长做什么。&lt;/p>&lt;p>当然，我肯定是没想清楚，不过我大致想做什么的想法了，于是在8月，我离开了，比较任性的裸辞了。&lt;/p>&lt;hr>&lt;p>之后的之后，我换了城市，做起了我喜欢的Python开发，感谢读书时认识的那些人，素未谋面，但是他（她）们打开了我的视野，让我知道了Python。用着喜欢的Python，到现在，九个月了。&lt;/p>&lt;p>这九个月，身边的人来来去去，让我认识到了深圳速度。。而在之前，身边的人从认识到熟悉到离开，节奏远无法与现在相比。&lt;/p>&lt;p>工作上负责起以前不会做的，数据库设计，部署，运维。以前有人负责部署和运维，导致我对项目上线整个流程没什么了解，只负责开发。有了这些体会再回想当时领导对我说的关于项目目录结构以及配置文件的一些做法有了更深的认知。别人说了怎么做会避免坑，但是只知道生搬硬套免不了还是会犯错的，往往只有真的再踩了一次才能有深刻啊。&lt;/p>&lt;p>技术上比当初眉毛胡子一把抓，所主次了。买了不少书，电子的纸质的都有，电子的读了不少，纸质读的却不多。打算把这些书看完，然 多抓鱼卖二手去，之后只买电子不买纸质了。&lt;/p>&lt;p>Jay&lt;/p>&lt;p>2018-07-07&lt;/p>&lt;p>于深圳&lt;/p></description></item><item><title>Pathlib</title><link>https://laujay.com/posts/pathlib/</link><pubDate>Tue, 29 May 2018 10:20:20 +0800</pubDate><guid>https://laujay.com/posts/pathlib/</guid><description>&lt;p>在上次Python3 unknown 里我记录了Python3新加的一个库pathlib，还给了如下一个example&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> pathlib &lt;span style="color:#f92672">import&lt;/span> Path&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>directory &lt;span style="color:#f92672">=&lt;/span> Path(&lt;span style="color:#e6db74">&amp;#34;/etc&amp;#34;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>filepath &lt;span style="color:#f92672">=&lt;/span> directory &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hosts&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> filepath&lt;span style="color:#f92672">.&lt;/span>exists():&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#39;hosts exist&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不得不说path的操作真是高频。。最近写的项目里我就用了好几次，写在这里增加下example:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> pathlib &lt;span style="color:#f92672">import&lt;/span> Path&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">load_tdk&lt;/span>(section_name):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> root &lt;span style="color:#f92672">=&lt;/span> Path(__file__)&lt;span style="color:#f92672">.&lt;/span>parent&lt;span style="color:#f92672">.&lt;/span>parent&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config &lt;span style="color:#f92672">=&lt;/span> root &lt;span style="color:#f92672">/&lt;/span> Path(&lt;span style="color:#e6db74">&amp;#34;conf/tdk.json&amp;#34;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tdk &lt;span style="color:#f92672">=&lt;/span> json&lt;span style="color:#f92672">.&lt;/span>loads(config&lt;span style="color:#f92672">.&lt;/span>read_text())&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里将网站的seo的tdk.json文件导入并使用。省略了业务逻辑。这里展示的是获取到配置文件的目录，并且可以直接用read_text()将文件打开并以文本方式读取，还能以其他方式读取这里不展开了。&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>parent &lt;span style="color:#f92672">=&lt;/span> Path(Path&lt;span style="color:#f92672">.&lt;/span>cwd())&lt;span style="color:#f92672">.&lt;/span>parent&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>private_key_pem &lt;span style="color:#f92672">=&lt;/span> parent &lt;span style="color:#f92672">/&lt;/span> Path(&lt;span style="color:#e6db74">&amp;#34;conf/app_private_key.pem&amp;#34;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>public_key &lt;span style="color:#f92672">=&lt;/span> parent &lt;span style="color:#f92672">/&lt;/span> Path(&lt;span style="color:#e6db74">&amp;#34;conf/alipay_public.key&amp;#34;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app_private_key_path&lt;span style="color:#f92672">=&lt;/span>private_key_pem&lt;span style="color:#f92672">.&lt;/span>as_posix(),&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alipay_public_key_path&lt;span style="color:#f92672">=&lt;/span>public_key&lt;span style="color:#f92672">.&lt;/span>as_posix(),&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是更熟悉之后的做法, Path.cwd() 类似于linux的命令pwd获取从root到当前路径的绝对地址as_posix方法将包含文件名的路径转为字符串。&lt;/p></description></item><item><title>不知道的Python3特性</title><link>https://laujay.com/posts/python3-unknow/</link><pubDate>Sat, 12 May 2018 22:20:19 +0800</pubDate><guid>https://laujay.com/posts/python3-unknow/</guid><description>&lt;p>下面这几个是我日常基本没使用过的特性。&lt;/p>&lt;h2 id="高级解包">高级解包&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># in python2&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">2&lt;/span>]: a, b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">3&lt;/span>]: a, b &lt;span style="color:#f92672">=&lt;/span> b, a&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># now in python3&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">4&lt;/span>]: a, b, &lt;span style="color:#f92672">*&lt;/span>rest &lt;span style="color:#f92672">=&lt;/span> range(&lt;span style="color:#ae81ff">10&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">5&lt;/span>]: print(a)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">6&lt;/span>]: print(b)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">7&lt;/span>]: print(rest)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">8&lt;/span>]: a, &lt;span style="color:#f92672">*&lt;/span>rest, b &lt;span style="color:#f92672">=&lt;/span> range(&lt;span style="color:#ae81ff">10&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">9&lt;/span>]: print(a)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">10&lt;/span>]: print(rest)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>]&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">11&lt;/span>]: print(b)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">9&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="强制关键词参数">强制关键词参数&lt;/h2>&lt;p>如果不想用*args收集多余参数你可能这么写&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">14&lt;/span>]: &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mysum&lt;/span>(a, b, biteme&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">if&lt;/span> biteme:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: print(&lt;span style="color:#e6db74">&amp;#39;一键删库&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">else&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> b&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">15&lt;/span>]: mysum(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Out[&lt;span style="color:#ae81ff">15&lt;/span>]: &lt;span style="color:#ae81ff">3&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">16&lt;/span>]: mysum(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#75715e"># if this is delete DB?&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>一键删库&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">18&lt;/span>]: &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">mysum&lt;/span>(a, b, &lt;span style="color:#f92672">*&lt;/span>, biteme&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">if&lt;/span> biteme:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: print(&lt;span style="color:#e6db74">&amp;#39;一键删库&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">else&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> b&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">19&lt;/span>]: mysum(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#75715e"># now raise TypeError&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">---------------------------------------------------------------------------&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">TypeError&lt;/span> Traceback (most recent call last)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>ipython&lt;span style="color:#f92672">-&lt;/span>input&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">19&lt;/span>&lt;span style="color:#f92672">-&lt;/span>eb8c192f30fb&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>module&lt;span style="color:#f92672">&amp;gt;&lt;/span>()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">----&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> mysum(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">TypeError&lt;/span>: mysum() takes &lt;span style="color:#ae81ff">2&lt;/span> positional arguments but &lt;span style="color:#ae81ff">3&lt;/span> were given&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="新的标准库">新的标准库&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">22&lt;/span>]: &lt;span style="color:#f92672">import&lt;/span> ipaddress&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">23&lt;/span>]: print(ipaddress&lt;span style="color:#f92672">.&lt;/span>ip_address(&lt;span style="color:#e6db74">&amp;#39;192.168.0.1&amp;#39;&lt;/span>))&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: print(ipaddress&lt;span style="color:#f92672">.&lt;/span>ip_address(&lt;span style="color:#e6db74">&amp;#39;2001:db8::&amp;#39;&lt;/span>))&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">192.168.0.1&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2001&lt;/span>:db8::&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">24&lt;/span>]: &lt;span style="color:#f92672">from&lt;/span> functools &lt;span style="color:#f92672">import&lt;/span> lru_cache&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#f92672">from&lt;/span> urllib.error &lt;span style="color:#f92672">import&lt;/span> HTTPError&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#f92672">import&lt;/span> urllib.request&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [&lt;span style="color:#ae81ff">25&lt;/span>]: &lt;span style="color:#a6e22e">@lru_cache&lt;/span>(maxsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_pep&lt;/span>(num):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;Retrieve text of a Python Enhancement Proposal&amp;#39;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: resource &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;http://www.python.org/dev/peps/pep-&lt;/span>&lt;span style="color:#e6db74">%04d&lt;/span>&lt;span style="color:#e6db74">/&amp;#39;&lt;/span> &lt;span style="color:#f92672">%&lt;/span> num&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">try&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">with&lt;/span> urllib&lt;span style="color:#f92672">.&lt;/span>request&lt;span style="color:#f92672">.&lt;/span>urlopen(resource) &lt;span style="color:#66d9ef">as&lt;/span> s:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">return&lt;/span> s&lt;span style="color:#f92672">.&lt;/span>read()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">except&lt;/span> HTTPError:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>: &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Not Found&amp;#39;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>:&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="pahtlib">pahtlib&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> pathlib &lt;span style="color:#f92672">import&lt;/span> Path&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>directory &lt;span style="color:#f92672">=&lt;/span> Path(&lt;span style="color:#e6db74">&amp;#34;/etc&amp;#34;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>filepath &lt;span style="color:#f92672">=&lt;/span> directory &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hosts&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> filepath&lt;span style="color:#f92672">.&lt;/span>exists():&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#39;hosts exist&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个比通常用os库做的优雅多了。。特别是filepath这句特别黑魔法, 把dunder方法&lt;code>__div__&lt;/code>用的很溜。&lt;/p></description></item><item><title>Tornado执行阻塞函数</title><link>https://laujay.com/posts/tornado-run-blocking-function/</link><pubDate>Wed, 18 Apr 2018 09:32:17 +0800</pubDate><guid>https://laujay.com/posts/tornado-run-blocking-function/</guid><description>&lt;h2 id="使用tornado时执行阻塞函数的姿势">使用Tornado时执行阻塞函数的姿势&lt;/h2>&lt;p>很多人使用Tornado的姿势其实都是不对的，很多人都是知乎style地使用Tornado，当然这话是大佬说的。我脑补了下才反应过来什么叫知乎style，其实就指用Tornado，但是代码里却很多阻塞的。Tornado的文档guide里异步和非阻塞I/O节第二段就说了：&lt;code>为了尽量减少并发连接造成的开销，Tornado使用了一种单线程事件循环的方式。 这就意味着所有的应用代码都应该是异步非阻塞的, 因为在同一时间只有一个操作是有效的.&lt;/code>敲黑板了，这是官方原话，所以这就是正确的使用Tornado的姿势没跑了。&lt;/p>&lt;h2 id="所以有以下的操作让耗时的阻塞操作变异步的方式">所以有以下的操作让耗时的阻塞操作变异步的方式&lt;/h2>&lt;p>董伟明大佬的博文&lt;a href="http://www.dongwm.com/archives/shi-yong-tornadorang-ni-de-qing-qiu-yi-bu-fei-zu-sai/">使用tornado让你的请求异步非阻塞&lt;/a>说了我知道的和不知道的方式，欢迎补充。&lt;/p>&lt;h2 id="官方的做法是">官方的做法是？&lt;/h2>&lt;p>我想改变公司的知乎style代码，就去啃了下文档，才有了这篇文章的由来，在翻最新的5.x版本文档里，我想起了以前有些卡时间的操作都用了&lt;code>run_on_exexutor&lt;/code>于是就翻到这个函数的文档，然后发现文档里多了句这个&lt;code> In general, using run_in_executor when calling a blocking method is recommended instead of using this decorator when defining a method.&lt;/code>什么时候出现的难道是我以前看英文没认真。于是搜了下这个函数在&lt;a href="http://www.tornadoweb.org/en/stable/guide/coroutines.html#calling-blocking-functions">这里&lt;/a>在文档里看到了这个示例:&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@gen.coroutine&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">call_blocking&lt;/span>():&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">yield&lt;/span> IOLoop&lt;span style="color:#f92672">.&lt;/span>current()&lt;span style="color:#f92672">.&lt;/span>run_in_executor(blocking_func, args)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>UPDATE: 这里其实文档有错，在我提的issue之后，文档更为如下，一共需要三个参数&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">call_blocking&lt;/span>():&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> IOLoop&lt;span style="color:#f92672">.&lt;/span>current()&lt;span style="color:#f92672">.&lt;/span>run_in_executor(&lt;span style="color:#66d9ef">None&lt;/span>, blocking_func, args)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后跟一个大佬分享了，大佬说那这个blocking_func是任意的都可以么，于是带着这个疑问我再翻了下文档，点过去看到了这个函数的声明与注释，原来是5.0新加的。&lt;code>Runs a function in a concurrent.futures.Executor&lt;/code> 看到concurrent你们会想到啥，反正我脑子里冒出了ThreadPool和ProcessPool。&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">run_in_executor&lt;/span>(self, executor, func, &lt;span style="color:#f92672">*&lt;/span>args):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;Runs a function in a ``concurrent.futures.Executor``. If&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> ``executor`` is ``None``, the IO loop&amp;#39;s default executor will be used.&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> Use `functools.partial` to pass keyword arguments to ``func``.&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> .. versionadded:: 5.0&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ThreadPoolExecutor &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">raise&lt;/span> &lt;span style="color:#a6e22e">RuntimeError&lt;/span>(&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;concurrent.futures is required to use IOLoop.run_in_executor&amp;#34;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> executor &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">not&lt;/span> hasattr(self, &lt;span style="color:#e6db74">&amp;#39;_executor&amp;#39;&lt;/span>):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">from&lt;/span> tornado.process &lt;span style="color:#f92672">import&lt;/span> cpu_count&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>_executor &lt;span style="color:#f92672">=&lt;/span> ThreadPoolExecutor(max_workers&lt;span style="color:#f92672">=&lt;/span>(cpu_count() &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>))&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> executor &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>_executor&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c_future &lt;span style="color:#f92672">=&lt;/span> executor&lt;span style="color:#f92672">.&lt;/span>submit(func, &lt;span style="color:#f92672">*&lt;/span>args)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Concurrent Futures are not usable with await. Wrap this in a&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Tornado Future instead, using self.add_future for thread-safety.&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t_future &lt;span style="color:#f92672">=&lt;/span> Future()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>add_future(c_future, &lt;span style="color:#66d9ef">lambda&lt;/span> f: chain_future(f, t_future))&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> t_future&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>源码如上, 清晰明了，官方也是简单粗暴，耗时的我再开个线程池来处理就好了。以后如果阻塞的函数都可以用这个run_in_executor了。这样你的代码就能用正确的姿势跑在Tornado框架里了。&lt;/p>&lt;p>UPDATE: 我之前提到文档有错，在我提的issue之后，原本以为会从代码层面更改，结果只改了文档。然后我提了说这个做法不够优雅，实现run_in_executor的老外说，虽然是有点尴尬，不过asyncio也是这么处理的，那没辙就这样吧.感兴趣的可以看&lt;a href="https://github.com/tornadoweb/tornado/issues/2493">这里&lt;/a>&lt;/p>&lt;p>UPDATE: 我在上文写到了其实现简单粗暴，另开线程。这里要分享的一个坑就是与此相关的。&lt;/p>&lt;p>最近写的一个东西，使用了很早之前的torndb, 为了不阻塞，使用这个函数去跑，由于会有很高的写数据库。于是该系统很不稳定，经过排查发现之前这么用没出现问题，一个是因为当时没使用run_int_executor，而是上篇说的很阻塞的使用。在那种情况下由于tornado的单线程机制，不会有竞争，基本单数据库连接就够了。而如今用了很多多线程进行写后，数据连接的单例单连接, 而没有用连接池, 就会出现问题了。&lt;/p></description></item><item><title>CentOS升级HTTPS</title><link>https://laujay.com/posts/deploy_and_using_https/</link><pubDate>Thu, 28 Dec 2017 21:38:29 +0800</pubDate><guid>https://laujay.com/posts/deploy_and_using_https/</guid><description>&lt;h2 id="升级https">升级https&lt;/h2>&lt;p>最近需要将域名升级为https, 以满足安全性和一些第三方接口的要求。目前的技术栈为前端VUE, 后端为Tornado。Tornado负责接口的实现。&lt;/p>&lt;h2 id="具体步骤">具体步骤&lt;/h2>&lt;p>&lt;code>curl https://get.acme.sh | sh&lt;/code> 安装acme.sh&lt;/p>&lt;p>&lt;code>source ~/.bashrc &lt;/code>&lt;code>acme.sh --issue -d www.your-app.com -w /home/work/www/your-app/current/public&lt;/code> 这里的public需要通过域名外网可访问&lt;/p>&lt;pre tabindex="0">&lt;code>acme.sh --installcert -d www.your-app.com \ --keypath /home/work/www/ssl/www.your-app.com.key \ --fullchainpath /home/work/www/ssl/www.your-app.com.key.pem \ --reloadcmd &amp;#34;sudo service nginx force-reload&amp;#34;&lt;/code>&lt;/pre>&lt;p>这里是ubuntu上的用法,而我用的服务器是CentOS系统的,所以最后一句需要改为&lt;/p>&lt;pre tabindex="0">&lt;code>--reloadcmd &amp;#34;sudo systemctl reload nginx&amp;#34;&lt;/code>&lt;/pre>&lt;p>最后一句为了免密执行需要再设置下:&lt;code>sudo visudo&lt;/code>&lt;code>work ALL=(ALL) NOPASSWD: /bin/systemctl reload nginx&lt;/code> # work 是工作目录生成 dhparam.pem 文件:&lt;code>openssl dhparam -out /home/work/www/ssl/dhparam.pem 2048&lt;/code>&lt;/p>&lt;h2 id="遇到的问题">遇到的问题&lt;/h2>&lt;p>首先需要解决的是证书, 关于这点acme.sh解决了这个问题, 详细内容可以看参考。当生成证书, 写好nginx配置的时候, 测试配置的时候直接报错&lt;code>unknown directive &amp;quot;ssl&amp;quot;&lt;/code>。很明显ssl不支持, 查看配置确实是最初编译的时候没加入http_ssl_module,随后重新编译加上&lt;code>--with-http_ssl_module&lt;/code>, 于是就解决了这个问题。&lt;/p>&lt;h2 id="配置nginx">配置Nginx&lt;/h2>&lt;pre tabindex="0">&lt;code>server { listen 443 ssl; server_name subdomain.dommain.com; ssl_certificate /home/work/path/subdomain.domain.com.key.pem; ssl_certificate_key /home/work/path/subdomain.domain.com.key; ssl_dhparam /home/work/path/dhparam.pem;ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ...}&lt;/code>&lt;/pre>&lt;h2 id="http-强制跳转https">http 强制跳转https&lt;/h2>&lt;pre tabindex="0">&lt;code>server { listen 80;server_name subdomain.domain.com; rewrite /(.*) https://$http_host/$1 redirect;}&lt;/code>&lt;/pre>&lt;h2 id="最后检查并重启nginx">最后检查并重启nginx&lt;/h2>&lt;p>这个具体的命令依据不同版本的系统而不同, 更多内容看参考文章。&lt;/p>&lt;h2 id="使用-acmesh-给-nginx-安装-let-s-encrypt-提供的免费-ssl-证书httpsruby-chinaorgtopics31983">&lt;a href="https://ruby-china.org/topics/31983">使用 acme.sh 给 Nginx 安装 Let’ s Encrypt 提供的免费 SSL 证书&lt;/a>&lt;/h2>&lt;h2 id="--web">title: CentOS升级HTTPSdate: 2017-12-28 21:38:29categories: Nginxtags:- https- nginx- web&lt;/h2>&lt;h2 id="升级https-1">升级https&lt;/h2>&lt;p>最近需要将域名升级为https, 以满足安全性和一些第三方接口的要求。目前的技术栈为前端VUE, 后端为Tornado。Tornado负责接口的实现。&lt;/p>&lt;h2 id="具体步骤-1">具体步骤&lt;/h2>&lt;p>&lt;code>curl https://get.acme.sh | sh&lt;/code> 安装acme.sh&lt;/p>&lt;p>&lt;code>source ~/.bashrc &lt;/code>&lt;code>acme.sh --issue -d www.your-app.com -w /home/work/www/your-app/current/public&lt;/code> 这里的public需要通过域名外网可访问&lt;/p>&lt;pre tabindex="0">&lt;code>acme.sh --installcert -d www.your-app.com \ --keypath /home/work/www/ssl/www.your-app.com.key \ --fullchainpath /home/work/www/ssl/www.your-app.com.key.pem \ --reloadcmd &amp;#34;sudo service nginx force-reload&amp;#34;&lt;/code>&lt;/pre>&lt;p>这里是ubuntu上的用法,而我用的服务器是CentOS系统的,所以最后一句需要改为&lt;/p>&lt;pre tabindex="0">&lt;code>--reloadcmd &amp;#34;sudo systemctl reload nginx&amp;#34;&lt;/code>&lt;/pre>&lt;p>最后一句为了免密执行需要再设置下:&lt;code>sudo visudo&lt;/code>&lt;code>work ALL=(ALL) NOPASSWD: /bin/systemctl reload nginx&lt;/code> # work 是工作目录生成 dhparam.pem 文件:&lt;code>openssl dhparam -out /home/work/www/ssl/dhparam.pem 2048&lt;/code>&lt;/p>&lt;h2 id="遇到的问题-1">遇到的问题&lt;/h2>&lt;p>首先需要解决的是证书, 关于这点acme.sh解决了这个问题, 详细内容可以看参考。当生成证书, 写好nginx配置的时候, 测试配置的时候直接报错&lt;code>unknown directive &amp;quot;ssl&amp;quot;&lt;/code>。很明显ssl不支持, 查看配置确实是最初编译的时候没加入http_ssl_module,随后重新编译加上&lt;code>--with-http_ssl_module&lt;/code>, 于是就解决了这个问题。&lt;/p>&lt;h2 id="配置nginx-1">配置Nginx&lt;/h2>&lt;pre tabindex="0">&lt;code>server { listen 443 ssl; server_name subdomain.dommain.com; ssl_certificate /home/work/path/subdomain.domain.com.key.pem; ssl_certificate_key /home/work/path/subdomain.domain.com.key; ssl_dhparam /home/work/path/dhparam.pem;ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ...}&lt;/code>&lt;/pre>&lt;h2 id="http-强制跳转https-1">http 强制跳转https&lt;/h2>&lt;pre tabindex="0">&lt;code>server { listen 80;server_name subdomain.domain.com; rewrite /(.*) https://$http_host/$1 redirect;}&lt;/code>&lt;/pre>&lt;h2 id="最后检查并重启nginx-1">最后检查并重启nginx&lt;/h2>&lt;p>这个具体的命令依据不同版本的系统而不同, 更多内容看参考文章。&lt;/p>&lt;p>&lt;a href="https://ruby-china.org/topics/31983">使用 acme.sh 给 Nginx 安装 Let’ s Encrypt 提供的免费 SSL 证书&lt;/a>&lt;/p></description></item><item><title>Pickle Error</title><link>https://laujay.com/posts/pickle-error/</link><pubDate>Tue, 17 Oct 2017 13:52:34 +0800</pubDate><guid>https://laujay.com/posts/pickle-error/</guid><description>&lt;h3 id="error-message">Error Message&lt;/h3>&lt;pre tabindex="0">&lt;code>cPickle.PicklingError: Can&amp;#39;t pickle&lt;/code>&lt;/pre>&lt;h3 id="shell">shell&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>python3 -m trace -tg --ignore-dir /Library $1&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="bug-code">bug code&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">process_way&lt;/span>():&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> workers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> futures&lt;span style="color:#f92672">.&lt;/span>ProcessPoolExecutor(workers) &lt;span style="color:#66d9ef">as&lt;/span> executor:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> futs &lt;span style="color:#f92672">=&lt;/span> {executor&lt;span style="color:#f92672">.&lt;/span>submit(blocking_way) &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">10&lt;/span>)}&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> len([fut&lt;span style="color:#f92672">.&lt;/span>result() &lt;span style="color:#66d9ef">for&lt;/span> fut &lt;span style="color:#f92672">in&lt;/span> futs])&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="reason">Reason&lt;/h3>&lt;pre tabindex="0">&lt;code>Pool methods all use a queue.Queue to pass tasks to the worker processes.Everything that goes through the queue.Queue must be pickable.So, multiprocessing can only transfer Python objects to worker processes which can be pickled.Functions are only picklable if they are defined at the top-level of a module, bound methods are not picklable.&lt;/code>&lt;/pre>&lt;h3 id="fixed">Fixed&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">process_way&lt;/span>():&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> workers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> futures&lt;span style="color:#f92672">.&lt;/span>ThreadPoolExecutor(workers) &lt;span style="color:#66d9ef">as&lt;/span> executor:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> futs &lt;span style="color:#f92672">=&lt;/span> {executor&lt;span style="color:#f92672">.&lt;/span>submit(blocking_way) &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">10&lt;/span>)}&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> len([fut&lt;span style="color:#f92672">.&lt;/span>result() &lt;span style="color:#66d9ef">for&lt;/span> fut &lt;span style="color:#f92672">in&lt;/span> futs])&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Blog Ci</title><link>https://laujay.com/posts/blog-ci/</link><pubDate>Sat, 15 Jul 2017 13:40:17 +0800</pubDate><guid>https://laujay.com/posts/blog-ci/</guid><description>&lt;p>比较早之前，我的博客用的是jeklly, 当时各种换插件和配置都很麻烦, 后来果断切到了hexo。当时想要用CI来做博客的自动生成，也省得每次换电脑都要重新安装hexo，可惜当时搞岔了travis的配置，导致次生成静态页面后push到github的候就挂了。于是一放就是几个月，这两天捡起来重新做，终于发现问题出在哪里了，于是记录下。&lt;/p>&lt;p>第一个问题是&lt;code>_config.yml&lt;/code>&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">deploy&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">git&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repo&lt;/span>: &lt;span style="color:#ae81ff">git@github.com:pyclear/pyclear.github.io.git&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">branch&lt;/span>: &lt;span style="color:#ae81ff">master&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里需要用ssh方式而不是http方式。&lt;/p>&lt;p>第二个是我查了好久的，一个travis的安全措施导致，就算执行成功了还不会停下而是超时失败。解决这个问题需要在.travis.yml里ssh-add那这么写&lt;/p>&lt;pre tabindex="0">&lt;code class="language-ymal" data-lang="ymal">- eval $(ssh-agent -s)- ssh-agent -k&lt;/code>&lt;/pre>&lt;p>ssh-agent后需要执行带k参数的，把ssh-agent进程杀掉不然travis由于有进程在跑，会没有输出，就算执成功了状态依旧会显示执行失败的。&lt;/p></description></item><item><title>Argparse</title><link>https://laujay.com/posts/argparse/</link><pubDate>Fri, 09 Dec 2016 22:19:43 +0800</pubDate><guid>https://laujay.com/posts/argparse/</guid><description>&lt;p>argparse是一个命令行解析的标准库，通过参数可以根据add_argument()的action选项触发不同的action。&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># arg-demo.py&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> argparse&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_args&lt;/span>():&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser &lt;span style="color:#f92672">=&lt;/span> argparse&lt;span style="color:#f92672">.&lt;/span>ArgumentParser(&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;demo argument parser&amp;#34;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> epilog&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;example usage&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser&lt;span style="color:#f92672">.&lt;/span>add_argument(&lt;span style="color:#e6db74">&amp;#39;-l&amp;#39;&lt;/span>,action&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;show&amp;#34;&lt;/span>, required&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> help&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;Help text for option x&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser&lt;span style="color:#f92672">.&lt;/span>add_arguemtn(&lt;span style="color:#e6db74">&amp;#39;-a&amp;#39;&lt;/span>,help&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;show all file&amp;#34;&lt;/span>,default&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(parser&lt;span style="color:#f92672">.&lt;/span>parse_args()) &lt;span style="color:#75715e"># parse_args()用来参数解析&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>:&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> get_args() &lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>python3 arg_demo&lt;span style="color:#f92672">.&lt;/span>py &lt;span style="color:#f92672">-&lt;/span>x testing &lt;span style="color:#75715e"># Namespace(l=&amp;#39;testing&amp;#39;, a=False)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>required=True保证了在命令调用的时候一定要上-l参数,也就是其他都是可选参数而－l参数是必须的。输出的结果显示带参数执行会在namespace里加上参数和参数值, 完全可以理解为命令空间内的全局变量。default保证了&lt;code>－a&lt;/code>参数的默认值为False, 实际上如果不加的话，如果使用的时候没使用这个参数。那么默认值为None。&lt;/p>&lt;p>显然，现在例子中的都是可以同时使用的参数。有些时候一些参数提供的功能没法同时使用，这时候需要使用互斥分组,&lt;code>add_mutually_execlusive_group&lt;/code>&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>group &lt;span style="color:#f92672">=&lt;/span> parser&lt;span style="color:#f92672">.&lt;/span>add_mutually_exclusive_group()&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>group&lt;span style="color:#f92672">.&lt;/span>add_argument(&lt;span style="color:#e6db74">&amp;#39;-l&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;--execute&amp;#39;&lt;/span>,action&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;show&amp;#34;&lt;/span>,&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> help&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;Help text for option x&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>group&lt;span style="color:#f92672">.&lt;/span>add_arguemtn(&lt;span style="color:#e6db74">&amp;#39;-a&amp;#39;&lt;/span>,help&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;show all file&amp;#34;&lt;/span>,default&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果同时使用这两参数的话，会报错:&lt;/p>&lt;blockquote>&lt;p>error: argument -a: not allowed with argument -l/&amp;ndash;execute&lt;/p>&lt;/blockquote></description></item><item><title>Functools</title><link>https://laujay.com/posts/functools/</link><pubDate>Sat, 03 Dec 2016 20:49:16 +0800</pubDate><guid>https://laujay.com/posts/functools/</guid><description>&lt;h2 id="functools-module">functools module&lt;/h2>&lt;p>functools 模块包含了非常多很有用的函数，甚至可以说是比较常用的。这些函数主要用于创建高阶函数、函数式编程和装饰器的函数和装饰器。&lt;/p>&lt;h2 id="partial">partial&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">spam&lt;/span>(a,b,c,d):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(a,b,c,d)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">from&lt;/span> functools &lt;span style="color:#f92672">import&lt;/span> partial&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s1 &lt;span style="color:#f92672">=&lt;/span> partial(spam,&lt;span style="color:#ae81ff">1&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s1(&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>) &lt;span style="color:#75715e"># 1,2,3,4&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在类定义中使用partial, 那么这个函数的行为类似于静态方法而不是实例方法。&lt;/p>&lt;h2 id="reducefunction-items-initial">reduce(function, items [,initial])&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(a,b):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a&lt;span style="color:#f92672">+&lt;/span>b&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">from&lt;/span> functools &lt;span style="color:#f92672">import&lt;/span> reduce&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reduce(add, [i &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">11&lt;/span>)]) &lt;span style="color:#75715e"># 55&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从可迭代对象中取前两个值，交给作为第一个参数传入的处理函数处理(类似map的第一个参数)，完了再将函数的返回值与可迭代对象中的下一个值作为处理函数的值。从这可以知道这个处理函数必须要能接受两个参数。&lt;/p>&lt;h2 id="update_warpper">update_warpper&lt;/h2>&lt;p>我在之前的python-note中记录过一点，简单来说就是为了能够保有原始函数的包括docstring在内的一些属性而提供的。然而每次调用update_warpper不方便, 于是就有了下一小节的warps。&lt;/p>&lt;h2 id="warps">warps&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> functools &lt;span style="color:#f92672">import&lt;/span> wraps&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">corator&lt;/span>(func):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@wraps&lt;/span>(func)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">wrapper&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>args, &lt;span style="color:#f92672">**&lt;/span>kwargs):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#39;calling decorated function ..&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> wrapper&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@corator&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>():&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> docstring&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#39;called test function&amp;#39;&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(test&lt;span style="color:#f92672">.&lt;/span>__name__,test&lt;span style="color:#f92672">.&lt;/span>__doc__) &lt;span style="color:#75715e"># test docstring&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与update_warpper功能类似，但身为装饰器更容易使用。&lt;/p></description></item><item><title>Collections</title><link>https://laujay.com/posts/collections/</link><pubDate>Tue, 29 Nov 2016 23:35:32 +0800</pubDate><guid>https://laujay.com/posts/collections/</guid><description>&lt;h2 id="collections-module">collections module&lt;/h2>&lt;p>collections提供了些新类型：deque和defaultdict, namedtuple等。&lt;/p>&lt;h2 id="deque">deque&lt;/h2>&lt;p>deque是性能非常高的，插入和删除优化到接近O(1),并且具有很有意思的特性。&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">from&lt;/span> collections &lt;span style="color:#f92672">import&lt;/span> deque&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dq &lt;span style="color:#f92672">=&lt;/span> deque([&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>],&lt;span style="color:#ae81ff">12&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">15&lt;/span>):&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dq&lt;span style="color:#f92672">.&lt;/span>append(i) &lt;span style="color:#75715e">#添加到右端&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id(dq[&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#75715e">#4297546624&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id(dq[&lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#75715e">#4297546656&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dq&lt;span style="color:#f92672">.&lt;/span>append(&lt;span style="color:#ae81ff">18&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id(dq[&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#75715e">#4297546656&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用id来看添加值前后的内存地址会发现现的一个有意思的地方, 如果限制了大小，当满了以后那么添加新项目的话，会在相反的一端删除对象，添加了一个值后dq[0]的id变成了原来dq[1]的id值, 原来dq[0]里面的内容也被删除了, 这样的实现无疑保证了性能。&lt;/p>&lt;p>deque是双端队列，在插入的时侯性能极好并且deque是线程安全的，appendleft和append是用来分别在左端和右端添加数据。&lt;/p>&lt;p>还有个基于双端数据结构的函数：rotate, 它可以轻易的旋转所有项，rotate的参数值大小决定旋转步数，正负决定旋转方向, 正向右转，负向左转。&lt;/p>&lt;h2 id="defaultdict">defaultdict&lt;/h2>&lt;p>与字典基本一样，除了对不存在的键将调用default_factory提供的函数来提供默认值，实际上与字典get取值设置默认值类似，只不过换成key不存在设置该key的值，并将这个key与所调用函数生成的值保存起来.&lt;/p>&lt;h2 id="namedtuple">namedtuple&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">from&lt;/span> collections &lt;span style="color:#f92672">import&lt;/span> namedtuple&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NetAddress &lt;span style="color:#f92672">=&lt;/span> nametuple(&lt;span style="color:#e6db74">&amp;#39;NetAddress&amp;#39;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#39;hostname&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;port&amp;#39;&lt;/span>])&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">=&lt;/span> NetAddress(&lt;span style="color:#e6db74">&amp;#39;localhost&amp;#39;&lt;/span>,&lt;span style="color:#ae81ff">80&lt;/span>)&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a&lt;span style="color:#f92672">.&lt;/span>hostname &lt;span style="color:#75715e"># &amp;#39;localhost&amp;#39;&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a&lt;span style="color:#f92672">.&lt;/span>port &lt;span style="color:#75715e"># 80&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type(a) &lt;span style="color:#75715e"># ipython output __main__.NetAddress &lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> isinstance(a, tuple) &lt;span style="color:#75715e"># True&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实是构造了一个tuple的子类, 可以使用各种tuple的方法，但却提供了更方便的数据结构，isinstance验证了这点。namedtuple具备更小的内存消耗，但是.方式的属性访问没类快。&lt;/p>&lt;h2 id="源码">源码&lt;/h2>&lt;p>有个点得记下，看collections的源码的时候发现，其使用了个_collections模块, 在标准库根本找不到，后来在爆站找到答案，居然是个内置库，c写的。&lt;/p></description></item><item><title>glob</title><link>https://laujay.com/posts/glob/</link><pubDate>Sun, 27 Nov 2016 19:24:16 +0800</pubDate><guid>https://laujay.com/posts/glob/</guid><description>&lt;h2 id="glob-module">glob module&lt;/h2>&lt;p>glob通过匹配来查找文件，该模块暴露出来三个函数glob, iglob, escape&lt;/p>&lt;h2 id="glob">glob&lt;/h2>&lt;p>glob通过简单的匹配规则查找文件例如:*匹配所有?匹配一个字符&lt;/p>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> glob&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>glob&lt;span style="color:#f92672">.&lt;/span>glob(&lt;span style="color:#e6db74">&amp;#39;*&amp;#39;&lt;/span>) &lt;span style="color:#75715e"># 返回当前目录下所有的文件&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>glob&lt;span style="color:#f92672">.&lt;/span>glob(&lt;span style="color:#e6db74">&amp;#39;?.*&amp;#39;&lt;/span>) &lt;span style="color:#75715e">#返回所有文件名是一个字符的文件&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="iglob">iglob&lt;/h2>&lt;p>iglob与glob其实是一回事，区别在于一个返回list一个返回iter。事实上通过阅读代码你会发现，glob其实就是调用iglob,然后用list函数将iter值取出生成list&lt;/p>&lt;h2 id="escape">escape&lt;/h2>&lt;p>escapse功能比较简单，就转义掉特殊字符&lt;/p></description></item><item><title>Requests Encoding</title><link>https://laujay.com/posts/requests-encoding/</link><pubDate>Wed, 24 Aug 2016 20:48:15 +0800</pubDate><guid>https://laujay.com/posts/requests-encoding/</guid><description>&lt;h2 id="问题">问题&lt;/h2>&lt;p>我一直以为按照meta去搞编码就ok了，然而事实上是然并卵。。例子之一是199IT的网页，看到meta charset=&amp;ldquo;utf-8&amp;rdquo;在使用requests获取网页的时候，发现搞下来的中文文本都是乱码(response.text)。于是一脸懵逼的开始转码，开始试都不行直到试到了ISO－8859-1于是我就奇怪了，怎么搞的，然后我就开始搜索和研究。&lt;/p>&lt;h2 id="试验">试验&lt;/h2>&lt;p>第一步自然是怀疑requests了，因为我试过用wget获取发现毫无问题。于是就去看requests文档，发现了这么一段：&lt;/p>&lt;p>&lt;code>When you receive a response, Requests makes a guess at the encoding to use for decoding the response when you access the Response.text attribute. Requests will first check for an encoding in the HTTP header, and if none is present, will use chardet to attempt to guess the encoding. The only time Requests will not do this is if no explicit charset is present in the HTTP headersand the Content-Type header contains text. In this situation, RFC 2616 specifies that the default charset must be ISO-8859-1. Requests follows the specification in this case. If you require a different encoding, you can manually set the Response.encoding property, or use the rawResponse.content.&lt;/code>&lt;/p>&lt;p>然后我打印requests的response.encoding..结果是：&lt;/p>&lt;pre>&lt;code>ISO－8859-1&lt;/code>&lt;/pre>&lt;h2 id="解决">解决&lt;/h2>&lt;p>找到问题后直接&lt;/p>&lt;pre>&lt;code>response.encoding=&amp;quot;utf-8&amp;quot;&lt;/code>&lt;/pre>&lt;p>搞定&lt;/p></description></item><item><title>Pyspider Docker Deployment</title><link>https://laujay.com/posts/pyspider-docker-deployment/</link><pubDate>Mon, 18 Jul 2016 11:37:52 +0800</pubDate><guid>https://laujay.com/posts/pyspider-docker-deployment/</guid><description>&lt;h2 id="缘起">缘起&lt;/h2>&lt;p>最近在搞docker部署pyspider，pyspider是一个非常灵活用户友好的爬虫框架，基于该框架能够很容易写出可控的爬虫。由于对docker不够熟悉，花了不少时间在解决部署问题上，很多地方纠结了蛮久的。写点笔记记录使用经历。当然我最后还是没单机docker部署pyspider。。不过单机也用不着组件化。。&lt;/p>&lt;h2 id="首先将redis和postgresql启动">首先，将redis和postgresql启动&lt;/h2>&lt;pre>&lt;code># docker run --name postgres -v /data/postgres/:/var/lib/postgresql/data \-d -p $LOCAL_IP:5432:5432 -e POSTGRES_PASSWORD=&amp;quot;&amp;quot; postgres# docker run --name redis -d -p $LOCAL_IP:6379:6379 redis&lt;/code>&lt;/pre>&lt;h2 id="其次创建数据库用户和数据库">其次，创建数据库用户和数据库&lt;/h2>&lt;p>在实际部署中有个坑是这样的, docker-compose.yaml里db的用户名是由name@hostip里的name决定的，如果你没有创建name相应的role那么fetcher和processor会报错。创建完了role之后接着需要创建三个数据库taskdb,resultdb,projectdb。不会创建？&lt;/p>&lt;pre>&lt;code># docker exec -it postgres bash&lt;/code>&lt;/pre>&lt;p>然后在打开的容器shell里输入&lt;/p>&lt;pre>&lt;code>$ psql -U postgres&lt;/code>&lt;/pre>&lt;p>好剩下的增加root用户以及添加root所有的三个数据的postgresql操作可以看阮一峰的postgresql入门教程&lt;/p>&lt;h2 id="接着将调度器启动">接着，将调度器启动&lt;/h2>&lt;pre>&lt;code># docker run --name scheduler -d -p $LOCAL_IP:23333:23333 --restart=always binux/pyspider \--taskdb &amp;quot;sqlalchemy+postgresql+taskdb://binux@10.21.0.7/taskdb&amp;quot; \--resultdb &amp;quot;sqlalchemy+postgresql+resultdb://binux@10.21.0.7/resultdb&amp;quot; \--projectdb &amp;quot;sqlalchemy+postgresql+projectdb://binux@10.21.0.7/projectdb&amp;quot; \--message-queue &amp;quot;redis://10.21.0.7:6379&amp;quot; \&lt;/code>&lt;/pre>&lt;p>scheduler &amp;ndash;inqueue-limit 5000 &amp;ndash;delete-time 43200&lt;/p>&lt;p>这里的db的ip需要注意。我实际使用发现需要先&lt;code>docker exec -it postgres cat /etc/hosts&lt;/code> 看下容器内的ip然后写pgsql的ip，使用宿主机ip会有点问题。等我对docker更熟悉了估计能找出问题的解答。&lt;/p>&lt;p>还有个问题需要注意，调度器的&amp;ndash;message-quque的地址一定不能写错，如果写错那么就会出现单步你调试可以，但是一运行就会出现unknown project的情况。&lt;/p>&lt;pre>&lt;code>[E 160719 12:30:56 scheduler:238] unknown project: testdocker[I 160719 12:31:35 scheduler:505] in 5m: new:0,success:0,retry:0,failed:0[I 160719 12:32:35 scheduler:505] in 5m: new:0,success:0,retry:0,failed:0[I 160719 12:33:35 scheduler:505] in 5m: new:0,success:0,retry:0,failed:0[E 160719 12:33:44 scheduler:238] unknown project: test2[I 160719 12:34:35 scheduler:505] in 5m: new:0,success:0,retry:0,failed:0&lt;/code>&lt;/pre>&lt;h2 id="启动其它组件">启动其它组件&lt;/h2>&lt;p>在另外一台服务器使用docker-compose将其它组件启动启动&lt;code># docker-compose up&lt;/code>&lt;/p>&lt;p>compose.yaml的配置参照pyspider作者的&lt;a href="http://blog.binux.me/2016/05/deployment-of-demopyspiderorg/">部署博文&lt;/a>有删改我依据实际情况去掉了webui的负载均衡，以及改ip，改动不大，注意webui去掉负载均衡后需要自己将端口expose出来。&lt;/p></description></item><item><title>Docker基本使用</title><link>https://laujay.com/posts/docker-basic/</link><pubDate>Tue, 12 Jul 2016 09:13:45 +0800</pubDate><guid>https://laujay.com/posts/docker-basic/</guid><description>&lt;h2 id="docker使用笔记">docker使用笔记&lt;/h2>&lt;p>随用随记，并不成系统，主要是方便自己忘记的时候查阅。&lt;/p>&lt;h3 id="如何进入运行起来的docker-container">如何进入运行起来的docker container&lt;/h3>&lt;p>如果想要进去运行起来的container里看看日志什么的，那么使用docker 1.3之后添加的exec&lt;/p>&lt;pre>&lt;code>docker exec -i -t CONTAINER_ID bash&lt;/code>&lt;/pre>&lt;p>-i 其实是STDIN，也就是使用标准输入，这样你写的指令就能在容器里执行。-t 其实是tty的意思，就是使用终端，这样可以有个终端可以随时输入命令操作。&lt;/p>&lt;h3 id="查看log">查看log&lt;/h3>&lt;pre>&lt;code>docker log -f CONTAINTER_ID&lt;/code>&lt;/pre>&lt;h3 id="以及绝对路径">&lt;code>.&lt;/code>,&lt;code>./&lt;/code>,以及绝对路径&lt;/h3>&lt;p>写习惯了docker-compose.yaml就会出现一个问题: -v 给的路径写的时候常常会直接用相对路径&lt;code>.&lt;/code>或者&lt;code>./directory&lt;/code>，这在用yaml作为配置，用docker-compose编排叫起来docker组的时候是没有问题的, 解析yaml的时候会补全的。&lt;/p>&lt;p>但是直接用docker命令叫起单个container的时候那个值可是直接就给docker的，并不会解析补全路径，所以往往会报错。&lt;/p>&lt;p>所以之后养成的习惯就是直接用&lt;code>$(pwd)&lt;/code>这样可以避免出错，有时候忘了这茬还是会浪费点时间去看文档的。&lt;/p>&lt;h3 id="link-db-error">link db error&lt;/h3>&lt;p>习惯使用docker开发后，配置新项目的开发环境，经常会遇到的一个问题是数据库不存在。但是明明数据库那个docker，已经up了。其实原因很简单，docker link不可以&lt;code>refer to localhost&lt;/code>。而很多框架default的数据库的URI是localhost。在配置中将localhost改为DB那个container的名字就好了。&lt;/p>&lt;h3 id="删除退出的容器">删除退出的容器&lt;/h3>&lt;p>&lt;code>docker rm &lt;/code>docker ps -a |awk &amp;lsquo;{print $1}&amp;rsquo; | grep [0-9a-z]`&lt;/p>&lt;h3 id="删除none的镜像">删除none的镜像&lt;/h3>&lt;p>&lt;code>docker rmi $(docker images -f 'dangling=true' -q)&lt;/code>&lt;/p>&lt;h2 id="entrypoint">entrypoint&lt;/h2>&lt;p>今天在重新部署pyspider, 自己写了写代码利用框架，抽了个api出来，然而怎么放进docker里成了一个问题。一开始是直接mount一个文件夹进docker，然后进入docker，将代码复制进要的目录。准备重启进程的时候尴尬的事情发生了，docker-compose up起来的组件进程的pid是1，根本没办法kill掉再重启。&lt;/p>&lt;p>最后找到了docker-compose.yaml里command这一项，看完之后发现，都是参数。想了想去翻pyspider的Dockerfile，于是找了作者是怎么跑的:&lt;/p>&lt;pre>&lt;code>ENTRYPOINT ['pyspider']&lt;/code>&lt;/pre>&lt;p>找到了怎么跑的接下来就很简单了，首先写个shell，把原本作者写的命令以及参数都写进去，在这之上加入自己拷贝代码的shell语句。然后再在docker-compose.yaml里加上这么几行&lt;/p>&lt;pre>&lt;code>entrypoint: - bash - /code/replace.sh&lt;/code>&lt;/pre>&lt;p>然后再加个volume 把shell文件挂到docker的code目录就搞定了&lt;/p></description></item><item><title>Git手记</title><link>https://laujay.com/posts/git-note/</link><pubDate>Sun, 10 Jul 2016 18:32:28 +0800</pubDate><guid>https://laujay.com/posts/git-note/</guid><description>&lt;h2 id="经常碰到提交信息写错或者commit后临时又要添加文件的操作">经常碰到提交信息写错&amp;hellip;或者commit后临时又要添加文件的操作?&lt;/h2>&lt;p>那么可以这样：先提交forgotten_file&lt;/p>&lt;pre>&lt;code>$ git add forgoten_file&lt;/code>&lt;/pre>&lt;p>完了再&lt;/p>&lt;pre>&lt;code>$ git commit --amend&lt;/code>&lt;/pre>&lt;p>这样就可以把忘记的补上了，同时还可以修改说明&lt;/p>&lt;p>&lt;code>git commit --amend&lt;/code>命令需要的是提交的文件快照和之前一样，&lt;/p>&lt;p>所以上面的添加文件要在&lt;code>git commit&lt;/code>之前。&lt;/p>&lt;!-- raw HTML omitted -->&lt;h2 id="总有些文件会一不小心add进暂存区内取消暂存区的文件">总有些文件会一不小心add进暂存区内，取消暂存区的文件?&lt;/h2>&lt;p>在git status状态会有相应的信息提示，是git reset HEAD &lt;!-- raw HTML omitted -->&lt;/p>&lt;h2 id="已经commit了需要取消跟踪">已经commit了，需要取消跟踪？&lt;/h2>&lt;p>总有不小心跟踪了不该跟踪的文件的时候，这个时候需要从cached删除文件&lt;code>git rm --cached file&lt;/code>就派上用场了，如果是整个目录，那么这时候可以参考rm命令的参数。。 -rf 都派上用场了你没看错。。&lt;code>git rm -r --cached files/&lt;/code>极其好用。。整个文件夹都被干掉了。&lt;/p>&lt;h2 id="公司变土豪了买github私有库了">公司变土豪了，买github私有库了？&lt;/h2>&lt;p>转换仓库，从gitlab到github&lt;/p>&lt;p>&lt;code>git remote add upstream ssh://git@gitlab.xx.:workspace/project/pyclear.git&lt;/code>&lt;code>git remote set-url origin git@github.com:xxx/pyclear.git&lt;/code>&lt;/p>&lt;p>note: .git前的pyclear是Repositories，别误解&lt;/p>&lt;h2 id="想做点commit点省的误删但是那么多commit又很烦">想做点commit点省的误删，但是那么多commit又很烦？&lt;/h2>&lt;p>最近从&lt;a href="http://ajucs.com">阿驹&lt;/a>那学了一招&lt;/p>&lt;pre>&lt;code>git rebase -i 32db1a7e1....&lt;/code>&lt;/pre>&lt;p>先&lt;code>git log&lt;/code>找到你不想要保留的之前那个的hash，然后使用上面这条命令。就能进入一个编辑状态，然后再依据编辑状态的提示处理就ok了。很简单的。&lt;/p>&lt;h2 id="经常忘记你对当前的代码干了啥git操作">经常忘记你对当前的代码干了啥git操作?&lt;/h2>&lt;p>使用版本管理工具经常发生的一件事是，你对代码干了啥可以清楚的知道，但是维护过程中你使用了什么git操作，不知道了。这时候有几个做法，一个是history命令可以看出你之前的操作，但是如果时间久一点，那么命令一多你就难找了。&lt;code>git reflog&lt;/code>可以列出你之前的所有git操作，但是这个也是有时限的，好像是一个月，不过已经够了。&lt;/p>&lt;h2 id="代码出bug了不知道谁干的">代码出bug了。不知道谁干的？&lt;/h2>&lt;p>有时候会有冲突说，这bug是xxx写的，然后xxx不服。有版本管理很简单，能精确到某一行代码的作者是谁。&lt;code>git blame file&lt;/code>就能知道谁干的了。&lt;/p>&lt;h2 id="查看log想倒过来">查看log想倒过来？&lt;/h2>&lt;p>看代码的时候我喜欢一个commit看过去，但是有些commit多了log会很长于是log的参数&lt;code>--reverse&lt;/code>就派上用场了:&lt;code>git log --reverse&lt;/code>这命令会把commit按时间线从第一个开始递增展示&lt;/p>&lt;h2 id="只拉某一个分支">只拉某一个分支&lt;/h2>&lt;p>由于我将博客的md文件放在github博客仓库的dev分支，在外的时候不想把build好的html也搞下来所以要指定clone分支&lt;code>git clone -b &amp;lt;branch&amp;gt; &amp;lt;remote_repo&amp;gt;&lt;/code>&lt;/p>&lt;h2 id="分支重命名">分支重命名&lt;/h2>&lt;p>重命名分支&lt;code>git branch -m &amp;lt;oldname&amp;gt; &amp;lt;newname&amp;gt;&lt;/code>重命名当前分支&lt;code>git branch -m &amp;lt;newname&amp;gt;&lt;/code>&lt;/p>&lt;h2 id="命令行删除远程分支">命令行删除远程分支&lt;/h2>&lt;p>查看远程分支&lt;code>git branch -r &lt;/code>删除远程分支&lt;code>git push origin :want_delete_branch_name&lt;/code>&lt;/p>&lt;h2 id="拆分子模块并修改依赖">拆分子模块，并修改依赖&lt;/h2>&lt;p>&lt;code>git submodule add 仓库地址 路径&lt;/code>&lt;/p>&lt;p>git clone 的工程带有submodule时,因为并不会自动去拉取子模块需要执行：&lt;code>git submodule update --init --recursive&lt;/code>&lt;/p>&lt;h2 id="gitignore的写法">.gitignore的写法&lt;/h2>&lt;ul>&lt;li>所有空行或者以注释符号&lt;code>#&lt;/code>开头的都会被Git忽略&lt;/li>&lt;li>可以使用标准的glob模式匹配(shell所使用的简化略的正则表达式)&lt;/li>&lt;li>匹配模式最后跟反斜杠(&lt;code>/&lt;/code>)说明要忽略的是目录&lt;/li>&lt;li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号取反&lt;/li>&lt;/ul>&lt;h2 id="同步fork库">同步fork库&lt;/h2>&lt;p>经常会记不住同步的方式，特地记录下其实很简单&lt;code>git remote add upstream URL&lt;/code>&lt;code>git fetch upstream&lt;/code>&lt;code>git merge upstraem/upstream&lt;/code>&lt;/p></description></item><item><title>Ubuntu Bits Complie Bits Assembly</title><link>https://laujay.com/posts/ubuntu-bits-complie-bits-assembly/</link><pubDate>Fri, 08 Jul 2016 23:10:00 +0800</pubDate><guid>https://laujay.com/posts/ubuntu-bits-complie-bits-assembly/</guid><description>&lt;h2 id="64位ubuntu系统编译32位汇编">64位Ubuntu系统编译32位汇编&lt;/h2>&lt;h3 id="汇编链接生成可执行文件">汇编链接生成可执行文件&lt;/h3>&lt;pre>&lt;code>ld -o eatsyscall eatsycscall.o&lt;/code>&lt;/pre>&lt;h3 id="输出">输出&lt;/h3>&lt;p>&lt;em>ld:i386 architecture of input file &lt;code>eatsyscall.o' is incompatible with i386:x86-64 ouput&lt;/code>&lt;/em>&lt;/p>&lt;h3 id="解决">解决&lt;/h3>&lt;p>经过搜索64位下ld提供了一个选项-m emulation，简写-m。说明文档如下：&lt;/p>&lt;pre>&lt;code>-m emulation Emulate the emulation linker. You can list the available emulations with the --verbose or -V options. If the -m option is not used，the emulation is taken from the &amp;quot;LDEMULSYION&amp;quot; environment variable，if that is defined. Otherwise，the default emulation depends upon how the linker was configured.&lt;/code>&lt;/pre>&lt;p>即，这个选项可以模拟其他平台上的ld链接器。使用-m elf_i386可以模拟32位平台上ld指令。&lt;/p></description></item><item><title/><link>https://laujay.com/posts/total-occurrences-of-k-in-a-sorted-array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://laujay.com/posts/total-occurrences-of-k-in-a-sorted-array/</guid><description>&lt;p>Total Occurrences of k in a sorted array&lt;/p>&lt;p>first: liner scan, time O(n) space O(1)&lt;/p>&lt;p>two : binary search &amp;amp; liner scan. Time: O(logn)+O(n) = O(n) , sapce O(1)&lt;/p>&lt;p>thre binary search . O(logn)&lt;/p>&lt;p>binary search: mid = left+(right-left) / 2, don&amp;rsquo;t using (left+right) /2 it will overflow&lt;/p></description></item></channel></rss>